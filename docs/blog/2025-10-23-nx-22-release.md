---
title: 'Nx 22 Release: Expanding horizons with .NET and Maven support'
slug: nx-22-release
authors: ['Philip Fulcher']
tags: ['nx', 'release']
cover_image: /blog/images/2025-10-23/header.avif
description: 'Discover Nx 22: .NET and Maven support brings enterprise polyglot capabilities, plus pnpm catalog integration, release workflow improvements, and need-to-know breaking changes'
---

Nx 22 expands support beyond the JavaScript ecosystem with **first-class support for .NET and Maven**! Nx is now your go-to solution for polyglot monorepos. This release also introduces pnpm catalog support, enhances our release workflows, and ships important stability improvements.

We'll be talking about all of these changes and more in our live stream on **October 28 at 12pm EDT**. Tune in to connect with our Nx engineers and get your questions answered!

{% youtube src="https://www.youtube.com/watch?v=ycb5dPTeJF8" /%}

{% toc /%}

## Nx 21 brought massive improvements

If you've been heads-down lately, you might have missed some significant features that landed during the Nx 21 release cycle. Let's catch up on what shipped.

![Screenshot of the terminal UI for Nx, showing multiple tasks running](/blog/images/2025-10-23/tui-and-continuous-tasks.avif)

Nx 21 introduced [continuous tasks](/blog/nx-21-continuous-tasks) and the [Terminal UI](/blog/nx-21-terminal-ui), fundamentally changing how you work with long-running processes. You can now configure task dependencies that include persistent processes like dev servers. The new Terminal UI makes managing these parallel processes straightforward with a structured interface that separates your task list from log output. Navigate with arrow keys or Vim-style controls, and finding specific logs becomes trivial instead of tedious.

The release also brought [major framework updates with seamless migrations](/blog/nx-21-2-release): Angular 20 with automatic control flow syntax migration and experimental Vitest support, NestJS 11 with better logging and faster startup, and Storybook 9 with Vitest-powered component tests.

![Screenshot showing the output of the `configure-ai-agents` command](/blog/images/2025-10-10/configure-ai-agents.avif)

Enhanced AI integration arrived through the [`configure-ai-agents`](/blog/nx-highlights-oct-2025#configuring-ai-agents-gets-even-easier) command, giving tools like Cursor and Copilot deep understanding of your monorepo structure.

![Screenshot of the new graph ui](/blog/images/2025-10-10/new-graph.avif)

The [project graph was redesigned](/blog/nx-highlights-oct-2025#enhanced-graph-ui-and-controls) with composite mode as the default for better performance in large workspaces, while the new floating control panel centralizes all visualization options. [Vite 7 support](/blog/nx-highlights-oct-2025#enhanced-graph-ui-and-controls) keeps your tooling current, [Playwright test result merging](/blog/nx-highlights-oct-2025#merging-atomized-playwright-test-results) unifies atomized test outputs, and the [new @nx/docker plugin](/blog/seamless-deploys-with-docker) simplifies container deployments. Each update included automatic migrations through `nx migrate latest`, making upgrades straightforward.

## Nx Cloud has also grown by leaps and bounds

While Nx 21 continued development, big things happened on Nx Cloud as well.

![Self-Healing CI GitHub Comment](/blog/images/articles/self-healing-ghcomment-dark.avif)

[Self-Healing CI](/blog/whats-new-in-nx-self-healing-ci) reduces your Time to Green by suggesting fixes for your failing PRs. You can accept the changes as-is, or even enable [YOLO Mode](/blog/whats-new-in-nx-self-healing-ci#yolo-mode-with-autoapplyfixes) with `--auto-apply-fixes` to apply simple, straight-forward suggestions like formatting or linting issues.

![Screenshot of Workspace Graph showing multiple repositories](/blog/images/2025-08-05/workspace-graph.avif)

[Polygraph](/blog/nx-cloud-introducing-polygraph) is the Enterprise solution for managing workspaces across your organization. You're able to [automate consistency](/blog/nx-cloud-conformance-automate-consistency) and [visualize dependencies](/blog/nx-cloud-workspace-graph) across all of your repos, whether they're using Nx or not.

Now let's look at what's new in Nx 22.

## Maven support: Fleshing out Java Support

![Log output from a Maven build, shown in Nx Cloud](/blog/images/2025-10-23/maven.avif)

Following our success with the [Nx plugin for Gradle](/docs/technologies/java/gradle/introduction), we‚Äôre now bringing Maven support to Nx. Using Nx together with Maven provides Nx‚Äôs caching and task distribution to your Maven workspaces!

Adding Nx to an existing Maven project adds an `nx.json`, some `nx` wrapper binaries, and our Maven Plugin (`dev.nx.maven.nx-maven-plugin`) to the root `pom.xml`. The `@nx/maven` plugin automatically reflects Maven's modules and lifecycle into Nx's project graph. As your Maven modules and goals evolve, Nx will automatically pick them up without maintaining any additional configuration.

```bash
# Install Nx
brew install nx

# Navigate to a Maven project
cd /path/to/my-java-service

# Add Maven support
nx init # Select @nx/maven

# Nx automatically detects your Maven projects
nx show project my-java-service

# Run mvn install through Nx
nx install my-java-service

# Run Maven Goals through Nx
nx spring-boot:run my-java-service

# Run mvn verify for all projects
nx run-many -t verify
```

Like our other plugins, Maven support includes intelligent caching and distributed execution. Your Maven builds will benefit from Nx‚Äôs computation caching, which skips unnecessary rebuilds when nothing has changed. For teams using Nx Cloud, this means dramatically faster CI pipelines for your Java projects.

Maven support is experimental for now. This is an initial set of features that users can start to adopt; more features will be coming soon. We will be listening closely for feedback and continue making the Maven support better.

Combined with our existing Gradle support (which saw massive performance improvements in Nx 21), Nx now offers comprehensive support for the Java ecosystem.

[Learn more about the Maven plugin](/docs/technologies/java/maven/introduction)

## `@nx/dotnet`: Enterprise-ready .NET development

![Log output from a .NET build, shown in Nx Cloud](/blog/images/2025-10-23/dotnet.avif)

We‚Äôre bringing Nx to the .NET ecosystem! The new `@nx/dotnet` plugin automatically discovers your .NET projects and infers common targets like `build`, `test`, and `watch`. This means you can start working with your existing .NET solutions immediately without extra configuration.

```bash
# Add the .NET plugin to your workspace
nx add @nx/dotnet

# Generate a new .NET application
dotnet new webapi -o ./apps/my-api

# Run common .NET tasks
nx build my-api
nx test my-api
nx watch my-api
```

The plugin uses your existing `.csproj`, `.fsproj`, or `.vbproj` files while integrating with Nx‚Äôs task graph. This means you get intelligent caching for your .NET builds, distributed task execution on Nx Cloud, and accurate dependency tracking between your .NET projects and any JavaScript projects in your workspace.

This also opens up .NET to all of the CI performance gains offered by Nx Cloud, including remote caching, distributed task execution, flaky task retries, and self-healing CI.

Our `@nx/dotnet` plugin started life as a community plugin named `@nx-dotnet/core`, and we recommend all users migrate to `@nx/dotnet`. This plugin was created by our own [Craigory Coppola](https://github.com/AgentEnder) and reached NPM downloads of over 25k/week. During its life as a community plugin, multiple contributors like [Ben Callaghan](https://github.com/bcallaghan-et), [Christopher Leigh](https://github.com/Tungsten78), and [Paulo Oliveira](https://github.com/asinino) (among others) helped build and support it. [Visit the repo](https://github.com/nx-dotnet/nx-dotnet) and see how [a community](https://github.com/nx-dotnet/nx-dotnet/graphs/contributors) can come together to build something big.

[Explore the .NET plugin documentation](/docs/technologies/dotnet/introduction)

## pnpm catalog support: Simplified dependency management

Managing dependencies across a large monorepo can present challenges. Different projects might drift to different versions of the same package, creating inconsistencies and potential bugs. [pnpm catalogs](https://pnpm.io/catalogs) solve this by providing a centralized way to define and reference dependency versions.

Nx 22 now supports pnpm catalogs, automatically recognizing and formatting your catalog definitions during migrations. When you run `nx migrate`, Nx will now properly update versions defined in your catalogs and format the `pnpm-workspace.yaml` file to keep everything consistent.

```yaml
# pnpm-workspace.yaml
packages:
  - 'apps/*'
  - 'libs/*'
catalog:
  react: ^19.0.0
  typescript: ~5.7.0
  '@nx/react': 22.0.0
```

Your projects can then reference these versions using the `catalog:` protocol:

```json
{
  "dependencies": {
    "react": "catalog:"
  },
  "devDependencies": {
    "typescript": "catalog:",
    "@nx/react": "catalog:"
  }
}
```

This makes upgrading dependencies across your entire workspace much simpler. Update the version in one place, and all projects using that catalog entry automatically reference the new version. This pairs perfectly with Nx‚Äôs migration system, ensuring your entire monorepo stays in sync.

But this isn‚Äôt just for migrations: anything that handles dependencies in `package.json` files now supports catalogs. That means generators, `@nx/eslint` rules, module federation utilities, and lockfile pruning all support catalogs in your workspace.

Please note: while plugins maintained by the Nx team have been updated to support catalogs, community plugins that modify `package.json` files will still need to be updated to support pnpm catalogs. If you‚Äôre a plugin author, see the documentation for two helper functions to make this easy: [addDependenciesToPackageJson](/docs/reference/devkit/addDependenciesToPackageJson) and [getDependencyVersionFromPackageJson](/docs/reference/devkit/getDependencyVersionFromPackageJson)

[Learn more about dependency management with Nx](/docs/concepts/decisions/dependency-management)

## Enhanced `release` workflows

We've significantly improved `nx release` based on feedback from teams using it in production. Several important changes make the release process more intuitive and flexible, marking significant progress in our journey to fully support application releases alongside our powerful existing options for libraries.

{% callout type="info" title="Getting started with `nx release`" %}
Get started with `nx release` by watching this [free video course](https://www.epicweb.dev/tutorials/versioning-and-releasing-npm-packages-with-nx) over at Epic Web!
{% /callout %}

### Graph-aware dependent updates and filtering

Release groups for nx release are a powerful way to configure different parts of your workspace to be released in different ways. This is particularly important when separating our applications from our libraries, which often have very different needs.

Behind the scenes, nx release now constructs a dedicated `ReleaseGraph` to map out these relationships and allow for filtering (e.g. with `--projects/-p` or `--groups/-g`) and `updateDependents` to be fully aware of even the most complex group configurations.

Related to this, the `updateDependents` option for versioning has a new possible value: `"always"`. This will inform nx release to update dependency references in dependents wherever they may be, in whatever group, as long as that dependency relationship exists. Combined with the `ReleaseGraph` aware filtering, using `"updateDependents": "always"` means that if you had projectA in group1 depending on projectB in group2, and you ran `nx release -p projectB` or `nx release -g group2`, you would now update the dependent (projectA) reference on projectB, despite the fact that projectA was outside of the filter.

We feel that this behavior is actually what most people want, most of the time, so in this major release "always" became the default value for `updateDependents`. The existing options of "auto" and "never" still exist if you wish to go back to the previous behavior or customize it. If you are not leveraging multiple release groups then this change likely does not visibly impact you.

We have also added dedicated guides for:

- [Release Groups](/docs/guides/nx-release/release-groups)
- [Update Dependents](/docs/guides/nx-release/update-dependents)

### Cleaner configuration for `releaseTag*` options

A key aspect of many types of release workflows are git tags, because they inform nx release where to start looking for relevant changes. Over time, the number of options relevant to release tags (what structure/pattern they have, what branches to check, whether semver is required, relationship with docker version etc) has grown and grown.

We therefore felt like the repetition in `releaseTagPattern`, `releaseTagCheckBranchesWhen` etc could be better expressed via a `releaseTag` object with unprefixed nested properties.

For example, in Nx 21 some purely example config might look like:

```json
{
  "releaseTagPattern": "{projectName}@{version}",
  "releaseTagPatternCheckAllBranchesWhen": ["main", "develop"],
  "releaseTagPatternRequireSemver": false,
  "releaseTagPatternPreferDockerVersion": "both",
  "releaseTagPatternStrictPreid": true
}
```

In Nx 22, this same config will automatically be migrated to:

```json
{
  "releaseTag": {
    "pattern": "{projectName}@{version}",
    "checkAllBranchesWhen": ["main", "develop"],
    "requireSemver": false,
    "preferDockerVersion": "both",
    "strictPreid": true
  }
}
```

This is much easier to scan and helps keep relevant config grouped together. The previous properties will be supported until Nx 23, with the new ones taking priority.

### New programmatic API guide and enhancements for changelogs

We've added a [new guide](/docs/guides/nx-release/programmatic-api) for using the first-class programmatic API for `nx release`. It can be super useful for creating your own dynamic release scripts while still letting nx release do all the heavy lifting.

When using `releaseChangelog` function from the programmatic API there is now a `replaceExistingContents` option which allows you to fully overwrite the existing contents in your configured `CHANGELOG.md`.

If you are using our [`ReleaseClient` feature](/docs/guides/nx-release/programmatic-api#using-the-releaseclient-class), there are two improvements for you to be aware of:

- The `ReleaseClient` constructor now allows you to use the provided nx release config as the _only_ source of truth for release configuration, overwriting anything found in `nx.json`. You enable this by setting a second parameter of the constructor to `true` (documented in the guide above)

- You can now provide a reference to a custom changelog renderer directly on custom config that you provide to the `ReleaseClient` constructor instead of having to write it in its own file and provide a path.

All of these features together can be very useful for cases where you are writing very focused changelog generation scripts for only a subset of your workspace, such as one or more applications.

### Better conventional commit handling

The way Nx determines relevant conventional commits now matches the behavior of `nx affected`. This means you now have more control over what changes impact your releases, and are no longer limited to just the changed files within the commits. Things like "implicitDependencies" from `nx affected` will now work in this context.

[Explore the updated Nx Release documentation](/docs/features/manage-releases)

## AI agent configuration improvements

{% youtube src="https://youtu.be/8gdvIz2r_QM" /%}

We‚Äôve made it even easier to configure AI coding assistants to understand your Nx workspace. The `configure-ai-agents` command now validates your existing AI configuration files, ensuring tools like Cursor, GitHub Copilot, and other AI assistants have everything they need. If one of your agents isn‚Äôt up-to-date, you can re-run `npx nx configure-ai-agents` to update your config. If you‚Äôre using Nx Console, it will also check these automatically and suggest updates.

This feature becomes increasingly valuable as your workspace grows and includes projects across multiple technologies. Your AI assistant now understands not only your JavaScript projects, but also your .NET services, Maven applications, and how they all connect.

[Learn more about AI integration with Nx](/docs/features/enhance-ai)

## Module Federation updates

For teams using Module Federation, we‚Äôve enhanced support for TypeScript solution-style and package manager workspaces paradigms. This means Module Federation works whether you‚Äôre using TypeScript project references, traditional path mappings, and/or package manager workspaces.

This means we can follow best practices when working within TypeScript monorepos when configuring workspace dependencies for our Module Federation projects. We can also ensure Type Safety via standard Node Resolution rather than relying on TS Path Mappings, which can impact build/typecheck performance.

An example of a package.json for a host/consumer application would look like the following:

```json
{
  "name": "host",
  "version": "0.0.1",
  "private": true,
  "devDependencies": {
    "my-remote": "workspace:*",
    "my-shared-lib": "workspace:*"
  }
}
```

The corresponding remote application's package.json would contain:

```json
{
  "name": "my-remote",
  "version": "0.0.1",
  "private": true,
  "main": "./src/remote-entry.ts",
  "types": "./src/remote-entry.ts",
  "exports": {
    "./Module": "./src/remote-entry.ts"
  },
  "devDependencies": {
    "my-shared-lib": "workspace:*"
  }
}
```

We‚Äôve also improved support for Angular applications using Rspack with Module Federation, allowing for ESM with Module Federation (previously forced to CJS) which should help keep bundles smaller, and improving live reload support to prevent hot-update loops, making the development experience smoother and faster.

[Learn more about Module Federation](/docs/technologies/module-federation/concepts/module-federation-and-nx)

## Storybook enhancements

{% youtube src="https://youtu.be/URc1aQU0Scs?si=AyMHzEZ46Qy8dJ7U" /%}

The `@nx/storybook` plugin now automatically infers `watch-deps` and `build-deps` targets. This makes it easier to keep your Storybook in sync with your buildable libraries during development. When you‚Äôre working on a component library, your Storybook automatically rebuilds when dependencies change.

[Explore Storybook with Nx](/docs/technologies/test-tools/storybook/introduction)

## Breaking Changes

As promised, Nx 22 is focused on stability and cleanup. We‚Äôve removed several previously deprecated features to streamline the codebase and improve maintainability.

### Database-backed caching is now standard

The `NX_DISABLE_DB` environment variable has been removed. All workspaces now use the database-backed caching system introduced in Nx 20. If you were still using the legacy cache, this migration happens automatically.

### CreateNodes V1 removed

The older `createNodesV1` API for plugin authors has been removed. If you‚Äôve authored custom plugins, ensure they‚Äôve been migrated to `createNodesV2`. The V2 API provides better performance and more flexibility. For plugin authors be sure to read our [compatibility guide](/docs/extending-nx/createnodes-compatibility) to ensure your plugin uses the right API for your use case.

### Legacy TypeScript plugin behavior changed

The `useLegacyTypescriptPlugin` option now defaults to `false`. This means new workspaces automatically use the more efficient TypeScript handling introduced in Nx 21. Existing workspaces can continue using the legacy behavior if needed, but we recommend migrating to the new approach for better performance.

### Webpack and Rspack options cleanup

Several deprecated options have been removed from `@nx/webpack` and `@nx/rspack`:

- `deleteOutputPath`: Use the native build tool option instead
- `sassImplementation`: Configure Sass directly in your build tool config

The `@nx/rspack:application` generator has also been removed in favor of framework-specific options. Use `@nx/react:app`, `@nx/vue:app`, or similar generators with the `--bundler=rspack` flag instead.

### Nx Release legacy versioning removed

The deprecated legacy versioning implementation has been completely removed from `nx release`. If you set `release.version.useLegacyVersioning: true` in Nx 21, you‚Äôll need to migrate to the new versioning APIs before upgrading to Nx 22.

### Inlining feature removed from tsc and swc executors

The experimental and deprecated inlining feature has been removed from the `@nx/js:tsc` and `@nx/js:swc` executors. If you were relying on this feature, consider using a bundler like esbuild or webpack instead.

### npm legacy peer deps behavior changed

Nx no longer forces `--legacy-peer-deps` when running npm commands. This aligns with modern npm best practices and ensures your projects resolve dependencies correctly. If you need the legacy behavior, you can configure it in your `.npmrc` file.

### Deprecated simpleName option removed

The `simpleName` option has been removed from library generators. All libraries now use consistent naming based on your workspace configuration.

### Other removals

- The long-deprecated `decorate-cli` script has been removed
- Migrations prior to Nx 20 have been removed to reduce package size
- Deprecated Storybook generators have been removed: Use `@nx/storybook:configuration` instead of the old framework-specific generators

## Migrating to Nx 22

As always, updating to the latest version of Nx is straightforward:

```bash
nx migrate latest
```

This command analyzes your workspace and creates a migration file with all necessary updates. Review the changes, then apply them:

```bash
nx migrate --run-migrations
```

For a more visual migration experience, use the [Migrate UI in Nx Console](/docs/guides/nx-console/console-migrate-ui), which lets you review and approve each migration individually.

[Learn more about the migration process](/docs/features/automate-updating-dependencies)

## The nitty gritty

As always, there are many more improvements and fixes we couldn‚Äôt cover in detail. See our full [release notes on GitHub](https://github.com/nrwl/nx/releases/tag/22.0.0) for all the details.

Keep an eye on our [socials](/community) and subscribe to our [YouTube channel](https://www.youtube.com/@nxdevtools) for what‚Äôs coming next.

Learn more:

- üß† [Nx AI Docs](/docs/features/enhance-ai)
- üå©Ô∏è [Nx Cloud](/nx-cloud)
- üë©‚Äçüíª [Nx GitHub](https://github.com/nrwl/nx)
- üë©‚Äçüíª [Nx Console GitHub](https://github.com/nrwl/nx-console)
- üí¨ [Nx Official Discord Server](https://go.nx.dev/community)
- üìπ [Nx Youtube Channel](https://www.youtube.com/@nxdevtools)
