---
title: 'Nx 22 Release: Expanding the build platform'
slug: nx-22-release
authors: ['Philip Fulcher']
tags: ['nx', 'release']
cover_image: /blog/images/2025-10-23/header.avif
description: 'Discover Nx 22: .NET and Maven support brings enterprise polyglot capabilities, plus pnpm catalog integration, release workflow improvements, and need-to-know breaking changes'
pinned: true
---

Nx 22 represents six months of development focused on expanding our build platform that solves CI and amplifies AI-powered development. We've introduced new CI tools that fix PRs and report back to you, rewritten our graph visualization to handle repositories of any size, and introduced enterprise-ready support for .NET and Maven. Nx 22 delivers on our vision of making monorepo development better for everyone.

We talked about many of these changes and more in our live stream. Catch the replay here and subscribe to our channel so you're notified of the next opportunity to connect with our Nx engineers and get your questions answered!

{% youtube src="https://www.youtube.com/watch?v=ycb5dPTeJF8" /%}

{% toc /%}

## Nx is much more than the open source package

Before we dive into all the greatness of Nx 22, let us give you an overview of where we're heading. We want Nx to be more than just the fastest task orchestrator for monorepos. We want Nx to be a **comprehensive build platform** that provides solutions along every part of the software development lifecycle—whether you're developing locally, running your PRs on CI, or using AI-assisted software development.

All of this while **keeping the Nx platform modular**, allowing you to start lightweight and only add more features as you need them.

### Self-Healing CI reduces Time to Green

For several years, Nx Cloud has solved the pure speed challenges of CI pipelines through [remote caching](/docs/features/cache-task-results) and [distributed task execution](/docs/features/ci-features/distribute-task-execution). While this is a fundamental property, it is not the whole story of making you productive. A lot of time is lost just attending to broken PRs, iterating on them, and trying to get them to a green state. Solving this challenge has been a big focus for us in the last six months.

![Self-Healing CI GitHub Comment](/blog/images/articles/self-healing-ghcomment-dark.avif)

Self-Healing CI analyzes your failing PRs and suggests fixes automatically. You can review the fix, apply it locally, or accept it and have it pushed directly to your PR. This saves a lot of time as it doesn't require you to context switch, check out the PR branch, etc.

Nx is uniquely positioned for this challenge: it has knowledge of the workspace structure and dependencies, the exact tasks that failed on CI, their inputs, and all the detailed logs of the actual error. All this context allows Nx to generate the best possible fix for your PR.

> GitHub support is already available and **GitLab** is being tested right now.

You can enable Self-Healing CI for free. [Learn more here](/blog/whats-new-in-nx-self-healing-ci).

{% youtube src="https://www.youtube.com/watch?v=JW5Ki3PkRWA" /%}

### Nx Console stops context switching by keeping you in your IDE

We've always valued deep integration, and there's something special about seeing CI errors and Self-Healing CI fixes pop up right in your editor, without ever having to leave your IDE.

[Nx Console](/docs/getting-started/editor-setup) is how we integrate with your editor. It works for Visual Studio Code and JetBrains IDEs, and we've steadily made it a more and more valuable part of your development toolkit:

- To help you stay in the flow, it notifies you of the status of PRs and Self-Healing CI fixes right in your IDE.
- To help integrate your AI assistants, it can [add agent instructions](/docs/features/enhance-ai#setting-up-nx-mcp) to make the most of Nx and keep those instructions up-to-date.
- To help you migrate to newer versions, it has [Migrate UI](/docs/guides/nx-console/console-migrate-ui), a visual interface for running and approving migrations.

{% video-player src="/documentation/blog/media/nxconsole-ci-completion.mp4" alt="Nx Console CI Completion" autoPlay=true loop=true  /%}

[Learn more about Nx Console CI features](/blog/nx-cloud-pipelines-come-to-nx-console)

### Polygraph: Enterprise workspace management

We strongly believe in monorepos. But we also learned one important thing when working with a lot of our enterprise customers. Sometimes you just cannot migrate certain projects into the monorepo. But you'd ideally still want some of the visibility and consistency benefits. This is exactly what Polygraph is about.

![Screenshot of Workspace Graph showing multiple repositories](/blog/images/2025-08-05/workspace-graph.avif)

Polygraph is the Enterprise solution for managing workspaces across your organization. You can automate consistency and visualize dependencies across all of your repositories, whether they're using Nx or not. This gives large organizations visibility into their entire development ecosystem, helping identify duplicate dependencies, enforce architectural patterns, and understand cross-repository impacts.

[Explore Polygraph](/blog/nx-cloud-introducing-polygraph)

## Nx Graph can now handle the largest repos

While the Nx graph worked beautifully for small repositories it became essentially unusable in large workspaces. We heard your feedback and finally tackled this by completely rewriting the graph visualization. This rewrite has been many months in the making. It's hard to arrive at something that works intuitively for repositories with a dozen projects while also handling workspaces with thousands. But that's exactly what we've accomplished.

![Screenshot of the new graph ui](/blog/images/2025-10-10/new-graph.avif)

The graph now renders in composite mode by default, providing two key benefits: it looks cleaner and makes it usable in large workspaces. But we didn't just fix performance. We also redesigned the control panel and interface to make navigating large repos much simpler. The graph is also integrated directly into Nx Console for VS Code, Cursor, and JetBrains IDEs, and we've significantly improved its stability across all these platforms.

Take a look by running `nx graph` and read the documentation for more details.

[Explore the project graph documentation](/docs/features/explore-graph) or watch Chau's [quick walkthrough of the main features](https://youtu.be/xVom_9SvHL8).

## Much improved Terminal UI

We're not just focusing on buzzy new features like AI integration. We know developers choose Nx because we continually improve the core product: the tools you use every day to build, test, and deploy your applications.

![Screenshot of Nx Terminal UI showing a task list on the left and log output on the right.](/blog/images/2025-05-05/terminal-ui.avif)

In larger workspaces you typically run many tasks simultaneously. This creates a the challenge of keeping an overview of what is currently running and what the output of those tasks has been. In particular when you're running multiple [continuous tasks](https://nx.dev/docs/reference/project-configuration#continuous) where you have a backend server, frontend server and some watch tasks running at the same time. We wanted to create a single interface that gives you maximum overview and control while developing in an Nx monorepo.

The [Terminal UI](/docs/guides/tasks--caching/terminal-ui) (TUI) introduced in Nx 21 fundamentally changed how you interact with Nx.

![Terminal UI task list interface](/blog/images/2025-10-10/tui.avif)

But we're not done yet. We keep continuously improving the Terminal UI experience and collecting feedback from users. Since Nx 21, we've replaced pagination with smooth scrolling in the tasks list, making it easier to navigate through multiple running tasks. We've also refined the visual experience with improved title styling when panels are focused, better handling of placeholder entries when filtering tasks, and preventing unwanted scrolling when interacting with the task list.

These are small tweaks, but they add up to a much more polished experience when you're running continuous tasks or managing complex pipelines. And we're currently working on a bunch of additional improvements, including easier filtering within the log output, better searching of logs, and easier copy & pasting.

{% callout type="note" title="Windows Compatibility" %}
The initial Nx 21 release disabled the Terminal UI on Windows. We are continuing to work on Windows support, so stay tuned.
{% /callout %}

## Polyglot workspaces grow with First-Class Maven & .NET support

The value proposition of monorepos increases dramatically when you can bring backends and frontends together in a single workspace. The combination of comprehensive project understanding and polyglot support makes both developers and AI agents more effective. Developers can now make atomic changes that cross the frontend/backend boundary: if a payload or model changes from the backend, that change can also be made in the frontend in the same commit. Your entire project stays in a working state in each commit, rather than getting surprised when things break between deployments. When your AI assistant can see how your React frontend connects to your NET backend, it can provide better suggestions and catch potential issues across the entire stack.

### Maven support: Fleshing out Java Support

![Log output from a Maven build, shown in Nx Cloud](/blog/images/2025-10-23/maven.avif)

Following our success with the Nx plugin for Gradle, we're now bringing Maven support to Nx. Using Nx together with Maven provides Nx's caching and task distribution to your Maven workspaces.

Adding Nx to an existing Maven project adds an `nx.json`, some `nx` wrapper binaries, and our Maven Plugin (`dev.nx.maven.nx-maven-plugin`) to the root `pom.xml`. The `@nx/maven` plugin automatically reflects Maven's modules and lifecycle into Nx's project graph. As your Maven modules and goals evolve, Nx automatically picks them up without maintaining any additional configuration.

```bash
# Install Nx
brew install nx

# Navigate to a Maven project
cd /path/to/my-java-service

# Add Maven support
nx init # Select @nx/maven

# Nx automatically detects your Maven projects
nx show project my-java-service

# Run mvn install through Nx
nx install my-java-service

# Run Maven Goals through Nx
nx spring-boot:run my-java-service

# Run mvn verify for all projects
nx run-many -t verify
```

Like our other plugins, Maven support includes intelligent caching and distributed execution. Your Maven builds benefit from Nx's computation caching, which skips unnecessary rebuilds when nothing has changed. For teams using Nx Cloud, this means dramatically faster CI pipelines for your Java projects.

Maven support is experimental for now. This is an initial set of features that users can start to adopt; more features will be coming soon. We will be listening closely for feedback and continue making the Maven support better.

Combined with our existing Gradle support (which saw massive performance improvements in Nx 21), Nx now offers comprehensive support for the Java ecosystem.

[Learn more about the Maven plugin](/docs/technologies/java/maven/introduction)

### `@nx/dotnet`: Enterprise-ready .NET development

![Log output from a .NET build, shown in Nx Cloud](/blog/images/2025-10-23/dotnet.avif)

We're bringing Nx to the .NET ecosystem! The new `@nx/dotnet` plugin automatically discovers your .NET projects and infers common targets like `build`, `test`, and `watch`. This means you can start working with your existing .NET solutions immediately without extra configuration.

```bash
# Add the .NET plugin to your workspace
nx add @nx/dotnet

# Generate a new .NET application
dotnet new webapi -o ./apps/my-api

# Run common .NET tasks
nx build my-api
nx test my-api
nx watch my-api
```

The plugin uses your existing `.csproj`, `.fsproj`, or `.vbproj` files while integrating with Nx's [task graph](/docs/concepts/mental-model#the-task-graph). This means you get intelligent caching for your .NET builds, distributed task execution on Nx Cloud, and accurate dependency tracking between your .NET projects and any JavaScript projects in your workspace.

This also opens up .NET to all of the CI performance gains offered by Nx Cloud, including remote caching, distributed task execution, flaky task retries, and self-healing CI.

Our `@nx/dotnet` plugin started life as a community plugin named `@nx-dotnet/core`, and we recommend all users migrate to `@nx/dotnet`. This plugin was created by our own [Craigory Coppola](https://github.com/AgentEnder) and reached NPM downloads of over 25k/week. During its life as a community plugin, multiple contributors like [Ben Callaghan](https://github.com/bcallaghan-et), [Christopher Leigh](https://github.com/Tungsten78), and [Paulo Oliveira](https://github.com/asinino) (among others) helped build and support it. [Visit the repo](https://github.com/nx-dotnet/nx-dotnet) and see how [a community](https://github.com/nx-dotnet/nx-dotnet/graphs/contributors) can come together to build something big.

[Explore the .NET plugin documentation](/docs/technologies/dotnet/introduction)

### Gradle performance improvements

In Nx 21, we introduced massive performance improvements to `@nx/gradle`. We brought a Gradle plugin that provides Nx with project graph information and started sending tasks to Gradle in batches rather than one by one. To test the improvements, we forked the Spring Boot repo and converted it to use Nx. With the latest version of our plugin, we reduced CI times from 1 hour 44 minutes to 42 minutes—a 59.6% reduction in time.

[Check out the docs for more details.](/docs/technologies/java/introduction)

## Nx amplifies the effectiveness of AI

AI is here to stay. We're not interested in "vibe coding" but rather want to embed AI as another tool you can use to be more effective. And there's a similar trend unfolding right now, going from vibe coding to a more [AI-assisted development approach](https://x.com/addyosmani/status/1960034046177923457).

We're in an interesting position where [monorepos and AI can enhance each other](https://monorepo.tools/ai): monorepos provide the comprehensive context AI agents need to move beyond simple file edits, while AI agents can perform atomic cross-project changes that monorepos need.

To fully leverage this, we're designing every API twice now: once for developers and once for AI agents. This dual approach ensures that both you and your AI assistant can work effectively with your Nx workspace.

We've recently introduced a new command to help you configure AI coding assistants for your Nx workspace.

```shell
npx nx configure-ai-agents
```

{% youtube src="https://youtu.be/8gdvIz2r_QM" /%}

When running the command, you can opt into a set of AI tools Nx should configure for you. You can also run the command multiple times and it will validate your existing configuration with the latest suggestions from the Nx team and update them if necessary. Alternatively, if you're using Nx Console, it will verify in the background if there are any new updates available and notify you.

**So what's next?** We have a couple of interesting ideas we're currently exploring, such as helping set up Claude's Skills, enhancing [Nx migrations](https://nx.dev/docs/features/automate-updating-dependencies) with AI to help update your codebase automatically, and more innovative ways for AI to understand and work with your Nx workspace.

[Learn more about AI integration with Nx](/docs/features/enhance-ai)

## But wait, there's more!

Beyond our main priorities, Nx 22 includes several important improvements that make everyday development better.

### pnpm catalog support: Simplified dependency management

Managing dependencies across a large monorepo can present challenges. Different projects might drift to different versions of the same package, creating inconsistencies and potential bugs. [pnpm catalogs](https://pnpm.io/catalogs) solve this by providing a centralized way to define and reference dependency versions.

Nx 22 now supports pnpm catalogs, automatically recognizing and formatting your catalog definitions during migrations. When you run `nx migrate`, Nx will now properly update versions defined in your catalogs and format the `pnpm-workspace.yaml` file to keep everything consistent.

```yaml
# pnpm-workspace.yaml
packages:
  - 'apps/*'
  - 'libs/*'
catalog:
  react: ^19.0.0
  typescript: ~5.7.0
  '@nx/react': 22.0.0
```

Your projects can then reference these versions using the `catalog:` protocol:

```json
{
  "dependencies": {
    "react": "catalog:"
  },
  "devDependencies": {
    "typescript": "catalog:",
    "@nx/react": "catalog:"
  }
}
```

This makes upgrading dependencies across your entire workspace much simpler. Update the version in one place, and all projects using that catalog entry automatically reference the new version. This pairs perfectly with Nx's migration system, ensuring your entire monorepo stays in sync.

But this isn't just for migrations: anything that handles dependencies in `package.json` files now supports catalogs. That means generators, `@nx/eslint` rules, module federation utilities, and lockfile pruning all support catalogs in your workspace.

Please note: while plugins maintained by the Nx team have been updated to support catalogs, community plugins that modify `package.json` files will still need to be updated to support pnpm catalogs. If you're a plugin author, see the documentation for two helper functions to make this easy: [addDependenciesToPackageJson](/docs/reference/devkit/addDependenciesToPackageJson) and [getDependencyVersionFromPackageJson](/docs/reference/devkit/getDependencyVersionFromPackageJson)

[Learn more about dependency management with Nx](/docs/concepts/decisions/dependency-management)

### Enhanced `release` workflows

We've significantly improved `nx release` based on feedback from teams using it in production. Several important changes make the release process more intuitive and flexible, marking significant progress in our journey to fully support application releases alongside our powerful existing options for libraries.

{% callout type="info" title="Getting started with `nx release`" %}
Get started with `nx release` by watching this [free video course](https://www.epicweb.dev/tutorials/versioning-and-releasing-npm-packages-with-nx) over at Epic Web!
{% /callout %}

#### Graph-aware dependent updates and filtering

Release groups for nx release are a powerful way to configure different parts of your workspace to be released in different ways. This is particularly important when separating applications from libraries, which often have very different needs.

Behind the scenes, nx release now constructs a dedicated `ReleaseGraph` to map out these relationships and allow for filtering (e.g. with `--projects/-p` or `--groups/-g`) and `updateDependents` to be fully aware of even the most complex group configurations.

Related to this, the `updateDependents` option for versioning has a new possible value: `"always"`. This will inform nx release to update dependency references in dependents wherever they may be, in whatever group, as long as that dependency relationship exists. Combined with the `ReleaseGraph` aware filtering, using `"updateDependents": "always"` means that if you had projectA in group1 depending on projectB in group2, and you ran `nx release -p projectB` or `nx release -g group2`, you would now update the dependent (projectA) reference on projectB, despite the fact that projectA was outside of the filter.

We feel that this behavior is actually what most people want, most of the time, so in this major release "always" became the default value for `updateDependents`. The existing options of "auto" and "never" still exist if you wish to go back to the previous behavior or customize it. If you are not leveraging multiple release groups then this change likely does not visibly impact you.

We have also added dedicated guides for:

- [Release Groups](/docs/guides/nx-release/release-groups)
- [Update Dependents](/docs/guides/nx-release/update-dependents)

#### Cleaner configuration for `releaseTag*` options

A key aspect of many types of release workflows are git tags, because they inform nx release where to start looking for relevant changes. Over time, the number of options relevant to release tags (what structure/pattern they have, what branches to check, whether semver is required, relationship with docker version etc) has grown and grown.

We therefore felt like the repetition in `releaseTagPattern`, `releaseTagCheckBranchesWhen` etc could be better expressed via a `releaseTag` object with unprefixed nested properties.

For example, in Nx 21 some purely example config might look like:

```json
{
  "releaseTagPattern": "{projectName}@{version}",
  "releaseTagPatternCheckAllBranchesWhen": ["main", "develop"],
  "releaseTagPatternRequireSemver": false,
  "releaseTagPatternPreferDockerVersion": "both",
  "releaseTagPatternStrictPreid": true
}
```

In Nx 22, this same config will automatically be migrated to:

```json
{
  "releaseTag": {
    "pattern": "{projectName}@{version}",
    "checkAllBranchesWhen": ["main", "develop"],
    "requireSemver": false,
    "preferDockerVersion": "both",
    "strictPreid": true
  }
}
```

This is much easier to scan and helps keep relevant config grouped together. The previous properties will be supported until Nx 23, with the new ones taking priority.

#### New programmatic API guide and enhancements for changelogs

We've added a [new guide](/docs/guides/nx-release/programmatic-api) for using the first-class programmatic API for `nx release`. It can be super useful for creating your own dynamic release scripts while still letting nx release do all the heavy lifting.

When using `releaseChangelog` function from the programmatic API there is now a `replaceExistingContents` option which allows you to fully overwrite the existing contents in your configured `CHANGELOG.md`.

If you are using our [`ReleaseClient` feature](/docs/guides/nx-release/programmatic-api#using-the-releaseclient-class), there are two improvements for you to be aware of:

- The `ReleaseClient` constructor now allows you to use the provided nx release config as the _only_ source of truth for release configuration, overwriting anything found in `nx.json`. You enable this by setting a second parameter of the constructor to `true` (documented in the guide above)

- You can now provide a reference to a custom changelog renderer directly on custom config that you provide to the `ReleaseClient` constructor instead of having to write it in its own file and provide a path.

All of these features together can be very useful for cases where you are writing very focused changelog generation scripts for only a subset of your workspace, such as one or more applications.

#### Better conventional commit handling

The way Nx determines relevant conventional commits now matches the behavior of `nx affected`. This means you now have more control over what changes impact your releases, and are no longer limited to just the changed files within the commits. Things like "implicitDependencies" from `nx affected` will now work in this context.

[Explore the updated Nx Release documentation](/docs/features/manage-releases)

### Module Federation updates

For teams using Module Federation, we've enhanced support for TypeScript solution-style and package manager workspaces paradigms. This means Module Federation works whether you're using TypeScript project references, traditional path mappings, and/or package manager workspaces.

This means we can follow best practices when working within TypeScript monorepos when configuring workspace dependencies for our Module Federation projects. We can also ensure Type Safety via standard Node Resolution rather than relying on TS Path Mappings, which can impact build/typecheck performance.

An example of a package.json for a host/consumer application would look like the following:

```json
{
  "name": "host",
  "version": "0.0.1",
  "private": true,
  "devDependencies": {
    "my-remote": "workspace:*",
    "my-shared-lib": "workspace:*"
  }
}
```

The corresponding remote application's package.json would contain:

```json
{
  "name": "my-remote",
  "version": "0.0.1",
  "private": true,
  "main": "./src/remote-entry.ts",
  "types": "./src/remote-entry.ts",
  "exports": {
    "./Module": "./src/remote-entry.ts"
  },
  "devDependencies": {
    "my-shared-lib": "workspace:*"
  }
}
```

We've also improved support for Angular applications using Rspack with Module Federation, allowing for ESM with Module Federation (previously forced to CJS) which should help keep bundles smaller, and improving live reload support to prevent hot-update loops, making the development experience smoother and faster.

[Learn more about Module Federation](/docs/technologies/module-federation/concepts/module-federation-and-nx)

### Storybook enhancements

{% youtube src="https://youtu.be/URc1aQU0Scs?si=AyMHzEZ46Qy8dJ7U" /%}

The `@nx/storybook` plugin now automatically infers `watch-deps` and `build-deps` targets. This makes it easier to keep your Storybook in sync with your buildable libraries during development. When you're working on a component library, your Storybook automatically rebuilds when dependencies change.

[Explore Storybook with Nx](/docs/technologies/test-tools/storybook/introduction)

## Breaking Changes

Nx 22 isn't just about the new, it's also about stability and cleanup. We've removed several previously deprecated features to streamline the codebase and improve maintainability:

- **Database-backed caching is now standard** - The `NX_DISABLE_DB` environment variable has been removed. All workspaces now use the database-backed caching system (migration happens automatically).

- **CreateNodes V1 removed** - Plugin authors must migrate custom plugins to `createNodesV2` for better performance and flexibility. See our [compatibility guide](/docs/extending-nx/createnodes-compatibility) for details.

- **Legacy TypeScript plugin behavior changed** - `useLegacyTypescriptPlugin` now defaults to `false` for more efficient TypeScript handling. Existing workspaces can keep the legacy behavior if needed.

- **Webpack and Rspack options cleanup** - Removed deprecated options: `deleteOutputPath` (use native build tool option) and `sassImplementation` (configure in build tool config). The `@nx/rspack:application` generator is removed—use framework-specific generators like `@nx/react:app` or `@nx/vue:app` with `--bundler=rspack` instead.

- **Nx Release legacy versioning removed** - The deprecated legacy versioning implementation is completely removed. If you used `release.version.useLegacyVersioning: true` in Nx 21, migrate to the new versioning APIs before upgrading.

- **Inlining feature removed from tsc and swc executors** - The experimental inlining feature is removed from `@nx/js:tsc` and `@nx/js:swc`. Use a bundler like esbuild or webpack instead.

- **npm legacy peer deps behavior changed** - Nx no longer forces `--legacy-peer-deps`. Configure this in your `.npmrc` file if needed.

- **Deprecated simpleName option removed** - The `simpleName` option is removed from library generators. All libraries use consistent naming based on workspace configuration.

There have also been some other removals:

- The long-deprecated `decorate-cli` script has been removed
- Migrations prior to Nx 20 have been removed to reduce package size
- Deprecated Storybook generators have been removed: Use `@nx/storybook:configuration` instead of the old framework-specific generators

## Migrating to Nx 22

As always, updating to the latest version of Nx is straightforward:

```shell
nx migrate latest
```

This command analyzes your workspace and creates a migration file with all necessary updates. Review the changes, then apply them:

```shell
nx migrate --run-migrations
```

For a more visual migration experience, use the [Migrate UI in Nx Console](/docs/guides/nx-console/console-migrate-ui), which lets you review and approve each migration individually.

[Learn more about the migration process](/docs/features/automate-updating-dependencies)

## The nitty gritty

As always, there are many more improvements and fixes we couldn't cover in detail. See our full [release notes on GitHub](https://github.com/nrwl/nx/releases/tag/22.0.0) for all the details.

Keep an eye on our [socials](/community) and subscribe to our [YouTube channel](https://www.youtube.com/@nxdevtools) for what's coming next.

Learn more:

- 🧠 [Nx AI Docs](/docs/features/enhance-ai)
- 🌩️ [Nx Cloud](/nx-cloud)
- 👩‍💻 [Nx GitHub](https://github.com/nrwl/nx)
- 👩‍💻 [Nx Console GitHub](https://github.com/nrwl/nx-console)
- 💬 [Nx Official Discord Server](https://go.nx.dev/community)
- 📹 [Nx Youtube Channel](https://www.youtube.com/@nxdevtools)
