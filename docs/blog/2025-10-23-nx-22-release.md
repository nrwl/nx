---
title: 'Nx 22 Release: Expanding the build platform'
slug: nx-22-release
authors: ['Philip Fulcher']
tags: ['nx', 'release']
cover_image: /blog/images/2025-10-23/header.avif
description: 'Discover Nx 22: .NET and Maven support brings enterprise polyglot capabilities, plus pnpm catalog integration, release workflow improvements, and need-to-know breaking changes'
pinned: true
---

Nx 22 represents six months of development focused on expanding our build platform that solves CI and amplifies AI-powered development. We've introduced new CI tools that fix PRs and report back to you, rewritten our graph visualization to handle repositories of any size, and introduced enterprise-ready support for .NET and Maven. Nx 22 delivers on our vision of making monorepo development better for everyone.

We talked about many of these changes and more in our live stream. Catch the replay here and subscribe to our channel so you're notified of the next opportunity to connect with our Nx engineers and get your questions answered!

{% youtube src="https://www.youtube.com/watch?v=ycb5dPTeJF8" /%}

{% toc /%}

## Nx is much more than the open source package

Nx is part of a **comprehensive build platform**. For several years, Nx Cloud has solved the performance and reliability challenges of CI pipelines through [remote caching](/docs/features/cache-task-results) and [distributed task execution](/docs/features/ci-features/distribute-task-execution). In the last six months, we've released features that address the main CI problem developers face every day: broken PRs. But we're not just helping developers, we're building out Enterprise-level features that help architects and directors manage development across the entire organization.

### Self-Healing CI reduces Time to Green

![Self-Healing CI GitHub Comment](/blog/images/articles/self-healing-ghcomment-dark.avif)

Self-Healing CI analyzes your failing PRs and suggests fixes automatically. You can accept the changes as-is, or enable YOLO Mode with `--auto-apply-fixes` to automatically apply straightforward suggestions like formatting or linting issues.

When a PR fails, Self-Healing CI examines the failure, understands the context from your workspace structure, and generates a fix. This isn't just about catching simple errors‚Äîit understands your project dependencies, task configurations, and common patterns in your codebase to provide intelligent solutions.

> We support GitHub for now, but **GitLab support is coming.** We already have a working version and are about to release it soon.

[Learn more about Self-Healing CI](/blog/whats-new-in-nx-self-healing-ci)

{% youtube src="https://www.youtube.com/watch?v=JW5Ki3PkRWA" /%}

### Nx Console stops context switching by keeping you in your IDE

[Nx Console](/docs/getting-started/editor-setup) is our IDE plugin that works for Visual Studio Code and JetBrains IDEs, and we've steadily made it a more and more essential part of your development toolkit:

- To help you stay in the flow, it notifies you of the status of PRs and Self-Healing CI fixes right in your IDE.
- To help integrate your AI assistants, it can [add agent instructions](/docs/features/enhance-ai#setting-up-nx-mcp) to make the most of Nx and keep those instructions up-to-date.
- To help you migrate to newer version, it has [Migrate UI](/docs/guides/nx-console/console-migrate-ui), a visual interface for running and approving migrations.

{% video-player src="/documentation/blog/media/nxconsole-ci-completion.mp4" alt="Nx Console CI Completion" autoPlay=true loop=true  /%}

[Learn more about Nx Console CI features](/blog/nx-cloud-pipelines-come-to-nx-console)

### Polygraph: Enterprise workspace management

We strongly believe in monorepos, but we also learned one important thing when working with a lot of our enterprise customers: sometimes you just can't migrate certain projects into the monorepo. You still want some of the visibility and consistency benefits, and this is exactly what Polygraph is about.

![Screenshot of Workspace Graph showing multiple repositories](/blog/images/2025-08-05/workspace-graph.avif)

Polygraph is the Enterprise solution for managing workspaces across your organization. You can automate consistency and visualize dependencies across all of your repositories, whether they're using Nx or not. This gives large organizations visibility into their entire development ecosystem, helping identify duplicate dependencies, enforce architectural patterns, and understand cross-repository impacts.

[Explore Polygraph](/blog/nx-cloud-introducing-polygraph)

## Nx Graph can now handle the largest repos

![Screenshot of the new graph ui](/blog/images/2025-10-10/new-graph.avif)

We've always believed in powerful visualizations. In bigger repositories, interactive visual representations become indispensable for understanding how everything fits together. This belief in multimodality‚Äîviewing your workspace in the terminal when appropriate, but switching to rich visual interfaces for complex questions‚Äîdrives how we design Nx.

The graph rewrite has been many months in the making. It's hard to arrive at something that works intuitively for repositories with a dozen projects while also handling workspaces with thousands. But that's exactly what we've accomplished.

The graph now renders in composite mode by default, providing two key benefits: it looks cleaner and prevents crashes when visualizing large workspaces. For workspaces with thousands of projects, the composite mode makes the graph usable again.

We've significantly improved the graph experience with a redesigned control panel and interface. So not only can the graph render the largest repos, navigating them is simpler. Take a look by running `nx graph` and read the documentation for more details.

[Explore the project graph documentation](/docs/features/explore-graph)

### Improved editor integration stability

The graph isn't just a standalone tool: it's integrated directly into Nx Console, giving you quick access to visualizations right from your IDE. This seamless integration between terminal, IDE, and browser-based tools represents our commitment to meeting developers where they work.

We've worked hard to improve the stability of Nx Console for VS Code, Cursor, and JetBrains IDEs (like IntelliJ and WebStorm). Compared to a year ago, the error rate has dropped significantly, making these integrations more reliable for daily development work.

## Much improved Terminal UI

We're not just focusing on buzzy new features like AI integration. We know developers choose Nx because we continually improve the core product: the tools you use every day to build, test, and deploy your applications.

![Screenshot of Nx Terminal UI showing a task list on the left and log output on the right.](/blog/images/2025-05-05/terminal-ui.avif)

### Terminal UI fundamentals

The [Terminal UI](/docs/guides/tasks--caching/terminal-ui) (TUI) introduced in Nx 21 fundamentally changed how you interact with Nx. Rather than just seeing an output of logs, you now see currently running tasks in one panel with log outputs for the selected task appearing in a separate panel.

![Terminal UI task list interface](/blog/images/2025-10-10/tui.avif)

### Continuous improvements

Since Nx 21, we've continued refining the Terminal UI experience. We've replaced pagination with smooth scrolling in the tasks list, making it easier to navigate through multiple running tasks. We've also refined the visual experience with improved title styling when panels are focused, better handling of placeholder entries when filtering tasks, and preventing unwanted scrolling when interacting with the task list. These are small tweaks, but they add up to a much more polished experience when you're running continuous tasks or managing complex pipelines.

And we're not done yet: we're currently working on better searching of logs, as well as easier copy & pasting.

{% callout type="note" title="Windows Compatibility" %}
The initial Nx 21 release disabled the Terminal UI on Windows. We are continuing to work on Windows support, so stay tuned.
{% /callout %}

## Polyglot workspaces grow with First-Class Maven & .NET support

The value proposition of monorepos increases dramatically when you can bring backends and frontends together in a single workspace. The combination of comprehensive project understanding and polyglot support makes both developers and AI agents more effective. Developers can now make atomic changes that cross the frontend/backend boundary: if a payload or model changes from the backend, that change can also be made in the frontend in the same commit. Your entire project stays in a working state in each commit, rather than getting surprised when things break between deployments. When your AI assistant can see how your React frontend connects to your NET backend, it can provide better suggestions and catch potential issues across the entire stack.

### Maven support: Fleshing out Java Support

![Log output from a Maven build, shown in Nx Cloud](/blog/images/2025-10-23/maven.avif)

Following our success with the Nx plugin for Gradle, we're now bringing Maven support to Nx. Using Nx together with Maven provides Nx's caching and task distribution to your Maven workspaces.

Adding Nx to an existing Maven project adds an `nx.json`, some `nx` wrapper binaries, and our Maven Plugin (`dev.nx.maven.nx-maven-plugin`) to the root `pom.xml`. The `@nx/maven` plugin automatically reflects Maven's modules and lifecycle into Nx's project graph. As your Maven modules and goals evolve, Nx automatically picks them up without maintaining any additional configuration.

```bash
# Install Nx
brew install nx

# Navigate to a Maven project
cd /path/to/my-java-service

# Add Maven support
nx init # Select @nx/maven

# Nx automatically detects your Maven projects
nx show project my-java-service

# Run mvn install through Nx
nx install my-java-service

# Run Maven Goals through Nx
nx spring-boot:run my-java-service

# Run mvn verify for all projects
nx run-many -t verify
```

Like our other plugins, Maven support includes intelligent caching and distributed execution. Your Maven builds benefit from Nx's computation caching, which skips unnecessary rebuilds when nothing has changed. For teams using Nx Cloud, this means dramatically faster CI pipelines for your Java projects.

Maven support is experimental for now. This is an initial set of features that users can start to adopt; more features will be coming soon. We will be listening closely for feedback and continue making the Maven support better.

Combined with our existing Gradle support (which saw massive performance improvements in Nx 21), Nx now offers comprehensive support for the Java ecosystem.

[Learn more about the Maven plugin](/docs/technologies/java/maven/introduction)

### `@nx/dotnet`: Enterprise-ready .NET development

![Log output from a .NET build, shown in Nx Cloud](/blog/images/2025-10-23/dotnet.avif)

We're bringing Nx to the .NET ecosystem! The new `@nx/dotnet` plugin automatically discovers your .NET projects and infers common targets like `build`, `test`, and `watch`. This means you can start working with your existing .NET solutions immediately without extra configuration.

```bash
# Add the .NET plugin to your workspace
nx add @nx/dotnet

# Generate a new .NET application
dotnet new webapi -o ./apps/my-api

# Run common .NET tasks
nx build my-api
nx test my-api
nx watch my-api
```

The plugin uses your existing `.csproj`, `.fsproj`, or `.vbproj` files while integrating with Nx's [task graph](/docs/concepts/mental-model#the-task-graph). This means you get intelligent caching for your .NET builds, distributed task execution on Nx Cloud, and accurate dependency tracking between your .NET projects and any JavaScript projects in your workspace.

This also opens up .NET to all of the CI performance gains offered by Nx Cloud, including remote caching, distributed task execution, flaky task retries, and self-healing CI.

Our `@nx/dotnet` plugin started life as a community plugin named `@nx-dotnet/core`, and we recommend all users migrate to `@nx/dotnet`. This plugin was created by our own [Craigory Coppola](https://github.com/AgentEnder) and reached NPM downloads of over 25k/week. During its life as a community plugin, multiple contributors like [Ben Callaghan](https://github.com/bcallaghan-et), [Christopher Leigh](https://github.com/Tungsten78), and [Paulo Oliveira](https://github.com/asinino) (among others) helped build and support it. [Visit the repo](https://github.com/nx-dotnet/nx-dotnet) and see how [a community](https://github.com/nx-dotnet/nx-dotnet/graphs/contributors) can come together to build something big.

[Explore the .NET plugin documentation](/docs/technologies/dotnet/introduction)

### Gradle performance improvements

In Nx 21, we introduced massive performance improvements to `@nx/gradle`. We brought a Gradle plugin that provides Nx with project graph information and started sending tasks to Gradle in batches rather than one by one. To test the improvements, we forked the Spring Boot repo and converted it to use Nx. With the latest version of our plugin, we reduced CI times from 1 hour 44 minutes to 42 minutes‚Äîa 59.6% reduction in time.

[Check out the docs for more details.](/docs/technologies/java/introduction)

## Nx amplifies the effectiveness of AI

Multiple industry reports show massive AI adoption across development teams. We're starting to see vibe coding being replaced by AI-assisted development: smart engineers whose efforts are multiplied by AI. AI coding assistants are transforming how developers work, but their effectiveness depends on understanding your codebase's structure and relationships. Monorepos and AI enhance each other: monorepos provide the comprehensive context AI agents need to move beyond simple file edits, while AI agents can perform atomic cross-project changes that monorepos need.

We're designing every API twice now: once for developers and once for AI agents. This dual approach ensures that both you and your AI assistant can work effectively with your Nx workspace.

### Enhanced AI agent configuration

{% youtube src="https://youtu.be/8gdvIz2r_QM" /%}

We've made it even easier to configure AI coding assistants to understand your Nx workspace. The `configure-ai-agents` command now validates your existing AI configuration files, ensuring tools like Cursor, GitHub Copilot, and other AI assistants have everything they need. If one of your agents isn't up-to-date, you can re-run `npx nx configure-ai-agents` to update your config. If you're using Nx Console, it will also check these automatically and suggest updates.

This feature becomes increasingly valuable as your workspace grows and includes projects across multiple technologies. Your AI assistant now understands not only your JavaScript projects, but also your .NET services, Maven applications, and how they all connect.

[Learn more about AI integration with Nx](/docs/features/enhance-ai)

### The bigger picture: monorepos.tools/ai

We've launched [monorepos.tools/ai](https://monorepos.tools/ai) to explore how monorepos and AI coding assistants amplify each other. The site dives into why providing comprehensive workspace context makes AI agents dramatically more effective, and how Nx enables this through deep integration with tools like Claude, Cursor, and GitHub Copilot.

### What's coming next

We're actively working on even deeper AI integration. Expect to see support for Claude's Skills feature, agentic migrations that can help update your codebase automatically, and more innovative ways for AI to understand and work with your Nx workspace.

## But wait, there's more!

Beyond our main priorities, Nx 22 includes several important improvements that make everyday development better.

### pnpm catalog support: Simplified dependency management

Managing dependencies across a large monorepo can present challenges. Different projects might drift to different versions of the same package, creating inconsistencies and potential bugs. [pnpm catalogs](https://pnpm.io/catalogs) solve this by providing a centralized way to define and reference dependency versions.

Nx 22 now supports pnpm catalogs, automatically recognizing and formatting your catalog definitions during migrations. When you run `nx migrate`, Nx will now properly update versions defined in your catalogs and format the `pnpm-workspace.yaml` file to keep everything consistent.

```yaml
# pnpm-workspace.yaml
packages:
  - 'apps/*'
  - 'libs/*'
catalog:
  react: ^19.0.0
  typescript: ~5.7.0
  '@nx/react': 22.0.0
```

Your projects can then reference these versions using the `catalog:` protocol:

```json
{
  "dependencies": {
    "react": "catalog:"
  },
  "devDependencies": {
    "typescript": "catalog:",
    "@nx/react": "catalog:"
  }
}
```

This makes upgrading dependencies across your entire workspace much simpler. Update the version in one place, and all projects using that catalog entry automatically reference the new version. This pairs perfectly with Nx's migration system, ensuring your entire monorepo stays in sync.

But this isn't just for migrations: anything that handles dependencies in `package.json` files now supports catalogs. That means generators, `@nx/eslint` rules, module federation utilities, and lockfile pruning all support catalogs in your workspace.

Please note: while plugins maintained by the Nx team have been updated to support catalogs, community plugins that modify `package.json` files will still need to be updated to support pnpm catalogs. If you're a plugin author, see the documentation for two helper functions to make this easy: [addDependenciesToPackageJson](/docs/reference/devkit/addDependenciesToPackageJson) and [getDependencyVersionFromPackageJson](/docs/reference/devkit/getDependencyVersionFromPackageJson)

[Learn more about dependency management with Nx](/docs/concepts/decisions/dependency-management)

### Enhanced `release` workflows

We've significantly improved `nx release` based on feedback from teams using it in production. Several important changes make the release process more intuitive and flexible, marking significant progress in our journey to fully support application releases alongside our powerful existing options for libraries.

{% callout type="info" title="Getting started with `nx release`" %}
Get started with `nx release` by watching this [free video course](https://www.epicweb.dev/tutorials/versioning-and-releasing-npm-packages-with-nx) over at Epic Web!
{% /callout %}

#### Graph-aware dependent updates and filtering

Release groups for nx release are a powerful way to configure different parts of your workspace to be released in different ways. This is particularly important when separating applications from libraries, which often have very different needs.

Behind the scenes, nx release now constructs a dedicated `ReleaseGraph` to map out these relationships and allow for filtering (e.g. with `--projects/-p` or `--groups/-g`) and `updateDependents` to be fully aware of even the most complex group configurations.

Related to this, the `updateDependents` option for versioning has a new possible value: `"always"`. This will inform nx release to update dependency references in dependents wherever they may be, in whatever group, as long as that dependency relationship exists. Combined with the `ReleaseGraph` aware filtering, using `"updateDependents": "always"` means that if you had projectA in group1 depending on projectB in group2, and you ran `nx release -p projectB` or `nx release -g group2`, you would now update the dependent (projectA) reference on projectB, despite the fact that projectA was outside of the filter.

We feel that this behavior is actually what most people want, most of the time, so in this major release "always" became the default value for `updateDependents`. The existing options of "auto" and "never" still exist if you wish to go back to the previous behavior or customize it. If you are not leveraging multiple release groups then this change likely does not visibly impact you.

We have also added dedicated guides for:

- [Release Groups](/docs/guides/nx-release/release-groups)
- [Update Dependents](/docs/guides/nx-release/update-dependents)

#### Cleaner configuration for `releaseTag*` options

A key aspect of many types of release workflows are git tags, because they inform nx release where to start looking for relevant changes. Over time, the number of options relevant to release tags (what structure/pattern they have, what branches to check, whether semver is required, relationship with docker version etc) has grown and grown.

We therefore felt like the repetition in `releaseTagPattern`, `releaseTagCheckBranchesWhen` etc could be better expressed via a `releaseTag` object with unprefixed nested properties.

For example, in Nx 21 some purely example config might look like:

```json
{
  "releaseTagPattern": "{projectName}@{version}",
  "releaseTagPatternCheckAllBranchesWhen": ["main", "develop"],
  "releaseTagPatternRequireSemver": false,
  "releaseTagPatternPreferDockerVersion": "both",
  "releaseTagPatternStrictPreid": true
}
```

In Nx 22, this same config will automatically be migrated to:

```json
{
  "releaseTag": {
    "pattern": "{projectName}@{version}",
    "checkAllBranchesWhen": ["main", "develop"],
    "requireSemver": false,
    "preferDockerVersion": "both",
    "strictPreid": true
  }
}
```

This is much easier to scan and helps keep relevant config grouped together. The previous properties will be supported until Nx 23, with the new ones taking priority.

#### New programmatic API guide and enhancements for changelogs

We've added a [new guide](/docs/guides/nx-release/programmatic-api) for using the first-class programmatic API for `nx release`. It can be super useful for creating your own dynamic release scripts while still letting nx release do all the heavy lifting.

When using `releaseChangelog` function from the programmatic API there is now a `replaceExistingContents` option which allows you to fully overwrite the existing contents in your configured `CHANGELOG.md`.

If you are using our [`ReleaseClient` feature](/docs/guides/nx-release/programmatic-api#using-the-releaseclient-class), there are two improvements for you to be aware of:

- The `ReleaseClient` constructor now allows you to use the provided nx release config as the _only_ source of truth for release configuration, overwriting anything found in `nx.json`. You enable this by setting a second parameter of the constructor to `true` (documented in the guide above)

- You can now provide a reference to a custom changelog renderer directly on custom config that you provide to the `ReleaseClient` constructor instead of having to write it in its own file and provide a path.

All of these features together can be very useful for cases where you are writing very focused changelog generation scripts for only a subset of your workspace, such as one or more applications.

#### Better conventional commit handling

The way Nx determines relevant conventional commits now matches the behavior of `nx affected`. This means you now have more control over what changes impact your releases, and are no longer limited to just the changed files within the commits. Things like "implicitDependencies" from `nx affected` will now work in this context.

[Explore the updated Nx Release documentation](/docs/features/manage-releases)

### Module Federation updates

For teams using Module Federation, we've enhanced support for TypeScript solution-style and package manager workspaces paradigms. This means Module Federation works whether you're using TypeScript project references, traditional path mappings, and/or package manager workspaces.

This means we can follow best practices when working within TypeScript monorepos when configuring workspace dependencies for our Module Federation projects. We can also ensure Type Safety via standard Node Resolution rather than relying on TS Path Mappings, which can impact build/typecheck performance.

An example of a package.json for a host/consumer application would look like the following:

```json
{
  "name": "host",
  "version": "0.0.1",
  "private": true,
  "devDependencies": {
    "my-remote": "workspace:*",
    "my-shared-lib": "workspace:*"
  }
}
```

The corresponding remote application's package.json would contain:

```json
{
  "name": "my-remote",
  "version": "0.0.1",
  "private": true,
  "main": "./src/remote-entry.ts",
  "types": "./src/remote-entry.ts",
  "exports": {
    "./Module": "./src/remote-entry.ts"
  },
  "devDependencies": {
    "my-shared-lib": "workspace:*"
  }
}
```

We've also improved support for Angular applications using Rspack with Module Federation, allowing for ESM with Module Federation (previously forced to CJS) which should help keep bundles smaller, and improving live reload support to prevent hot-update loops, making the development experience smoother and faster.

[Learn more about Module Federation](/docs/technologies/module-federation/concepts/module-federation-and-nx)

### Storybook enhancements

{% youtube src="https://youtu.be/URc1aQU0Scs?si=AyMHzEZ46Qy8dJ7U" /%}

The `@nx/storybook` plugin now automatically infers `watch-deps` and `build-deps` targets. This makes it easier to keep your Storybook in sync with your buildable libraries during development. When you're working on a component library, your Storybook automatically rebuilds when dependencies change.

[Explore Storybook with Nx](/docs/technologies/test-tools/storybook/introduction)

## Breaking Changes

Nx 22 isn't just about the new, it's also about stability and cleanup. We've removed several previously deprecated features to streamline the codebase and improve maintainability.

### Database-backed caching is now standard

The `NX_DISABLE_DB` environment variable has been removed. All workspaces now use the database-backed caching system introduced in Nx 20. If you were still using the legacy cache, this migration happens automatically.

### CreateNodes V1 removed

The older `createNodesV1` API for plugin authors has been removed. If you've authored custom plugins, ensure they've been migrated to `createNodesV2`. The V2 API provides better performance and more flexibility. For plugin authors be sure to read our [compatibility guide](/docs/extending-nx/createnodes-compatibility) to ensure your plugin uses the right API for your use case.

### Legacy TypeScript plugin behavior changed

The `useLegacyTypescriptPlugin` option now defaults to `false`. This means new workspaces automatically use the more efficient TypeScript handling introduced in Nx 21. Existing workspaces can continue using the legacy behavior if needed, but we recommend migrating to the new approach for better performance.

### Webpack and Rspack options cleanup

Several deprecated options have been removed from `@nx/webpack` and `@nx/rspack`:

- `deleteOutputPath`: Use the native build tool option instead
- `sassImplementation`: Configure Sass directly in your build tool config

The `@nx/rspack:application` generator has also been removed in favor of framework-specific options. Use `@nx/react:app`, `@nx/vue:app`, or similar generators with the `--bundler=rspack` flag instead.

### Nx Release legacy versioning removed

The deprecated legacy versioning implementation has been completely removed from `nx release`. If you set `release.version.useLegacyVersioning: true` in Nx 21, you'll need to migrate to the new versioning APIs before upgrading to Nx 22.

### Inlining feature removed from tsc and swc executors

The experimental and deprecated inlining feature has been removed from the `@nx/js:tsc` and `@nx/js:swc` executors. If you were relying on this feature, consider using a bundler like esbuild or webpack instead.

### npm legacy peer deps behavior changed

Nx no longer forces `--legacy-peer-deps` when running npm commands. This aligns with modern npm best practices and ensures your projects resolve dependencies correctly. If you need the legacy behavior, you can configure it in your `.npmrc` file.

### Deprecated simpleName option removed

The `simpleName` option has been removed from library generators. All libraries now use consistent naming based on your workspace configuration.

### Other removals

- The long-deprecated `decorate-cli` script has been removed
- Migrations prior to Nx 20 have been removed to reduce package size
- Deprecated Storybook generators have been removed: Use `@nx/storybook:configuration` instead of the old framework-specific generators

## Migrating to Nx 22

As always, updating to the latest version of Nx is straightforward:

```bash
nx migrate latest
```

This command analyzes your workspace and creates a migration file with all necessary updates. Review the changes, then apply them:

```bash
nx migrate --run-migrations
```

For a more visual migration experience, use the [Migrate UI in Nx Console](/docs/guides/nx-console/console-migrate-ui), which lets you review and approve each migration individually.

[Learn more about the migration process](/docs/features/automate-updating-dependencies)

## The nitty gritty

As always, there are many more improvements and fixes we couldn't cover in detail. See our full [release notes on GitHub](https://github.com/nrwl/nx/releases/tag/22.0.0) for all the details.

Keep an eye on our [socials](/community) and subscribe to our [YouTube channel](https://www.youtube.com/@nxdevtools) for what's coming next.

Learn more:

- üß† [Nx AI Docs](/docs/features/enhance-ai)
- üå©Ô∏è [Nx Cloud](/nx-cloud)
- üë©‚Äçüíª [Nx GitHub](https://github.com/nrwl/nx)
- üë©‚Äçüíª [Nx Console GitHub](https://github.com/nrwl/nx-console)
- üí¨ [Nx Official Discord Server](https://go.nx.dev/community)
- üìπ [Nx Youtube Channel](https://www.youtube.com/@nxdevtools)
