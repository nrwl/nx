---
title: Debug NestJS Apps in Docker
description: Learn how to configure VSCode and IntelliJ IDEA to debug NestJS applications running in Docker containers, including Docker Compose setups with build directories.
keywords: [nestjs, docker, debug, vscode, intellij, ide, compose]
---

# Debug NestJS Apps in Docker

When developing NestJS applications in an Nx workspace that use Docker or Docker Compose, you'll often need to debug the application while it's running inside a container. This guide shows you how to set up debugging for containerized NestJS applications using VSCode and IntelliJ IDEA.

The key to debugging containerized Node.js applications is to:

1. Configure the Node.js process inside the container to listen for debugger connections
2. Expose the debug port from the container
3. Configure your IDE to connect to the debug port

## Step 1: Configure Docker for Debugging

### Using the Nx Docker Generator

First, set up Docker for your NestJS application:

```shell
nx g @nx/node:setup-docker my-nest-app
```

This creates a `Dockerfile` in your application directory.

### Modify Dockerfile for Debugging

The generated `Dockerfile` will use your project name (sanitized for Docker). Update it to support debugging by:

1. Adding the `EXPOSE 9229` directive for the debug port
2. Modifying the `CMD` to include the `--inspect` flag

For example, if your project is named `my-nest-app`, the Dockerfile will look like this:

```dockerfile
# This file is generated by Nx.
FROM docker.io/node:lts-alpine

ENV HOST=0.0.0.0
ENV PORT=3000

WORKDIR /app

RUN addgroup --system my-nest-app && \
          adduser --system -G my-nest-app my-nest-app

COPY dist/apps/my-nest-app my-nest-app/
COPY apps/my-nest-app/package.json my-nest-app/
RUN chown -R my-nest-app:my-nest-app .

RUN npm --prefix my-nest-app --omit=dev -f install

# Enable debugging - expose port 9229 for debugger (you can use any available port)
EXPOSE 9229

# Start with debug mode enabled (replace 'my-nest-app' with your sanitized project name)
CMD [ "node", "--inspect=0.0.0.0:9229", "my-nest-app" ]
```

{% callout type="warning" title="Project Name Sanitization" %}
Replace `my-nest-app` in the CMD line with the actual sanitized name generated for your project. For projects with special characters (like `@scope/my-app`), Nx sanitizes them to valid Docker names (like `scope-my-app`).
{% /callout %}

## Step 2: Configure Docker Compose

Create or update your `docker-compose.yml` to expose the debug port:

```yaml
version: '3.8'
services:
  my-nest-app:
    build:
      context: .
      dockerfile: apps/my-nest-app/Dockerfile
    ports:
      - '3000:3000' # Application port
      - '9229:9229' # Debug port (change if running multiple debuggers simultaneously)
    environment:
      - NODE_ENV=development
    volumes:
      # Optional: Mount source code for hot reloading during development
      - ./dist/apps/my-nest-app:/app/my-nest-app
    depends_on:
      - database

  database:
    # Your database configuration
    image: postgres:13
    # ... other database config
```

## Step 3: Configure IDE Debug Configuration

Configure your IDE to connect to the debug port. You can customize the debug port (9229) if running multiple debuggers simultaneously.

{% tabs %}
{% tab label="VSCode" %}

```json
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Docker: Attach to NestJS",
      "type": "node",
      "request": "attach",
      "port": 9229,
      "address": "localhost",
      "localRoot": "${workspaceFolder}",
      "remoteRoot": "/app",
      "protocol": "inspector",
      "restart": true,
      "sourceMaps": true,
      "skipFiles": ["<node_internals>/**"],
      "resolveSourceMapLocations": [
        "${workspaceFolder}/**",
        "!**/node_modules/**"
      ]
    },
    {
      "name": "Docker: Debug NestJS with Build",
      "type": "node",
      "request": "attach",
      "port": 9229,
      "address": "localhost",
      "localRoot": "${workspaceFolder}/apps/my-nest-app/src",
      "remoteRoot": "/app/my-nest-app",
      "protocol": "inspector",
      "restart": true,
      "sourceMaps": true,
      "skipFiles": ["<node_internals>/**"],
      "resolveSourceMapLocations": [
        "${workspaceFolder}/apps/my-nest-app/**",
        "${workspaceFolder}/dist/apps/my-nest-app/**",
        "!**/node_modules/**"
      ],
      "outFiles": ["${workspaceFolder}/dist/apps/my-nest-app/**/*.js"]
    }
  ]
}
```

{% /tab %}
{% tab label="IntelliJ IDEA" %}

Create a new **Attach to Node.js/Chrome** run configuration:

1. Go to **Run** → **Edit Configurations...**
2. Click the **+** button and select **Attach to Node.js/Chrome**
3. Configure the debug settings:
   - **Name**: `Docker: Debug NestJS`
   - **Host**: `localhost`
   - **Port**: `9229` (change if using a different port)
   - **Attach to**: `Chrome or Node.js > 6.3 started with --inspect`
4. In the **Before launch** section, you can optionally add:
   - **Build** task to ensure your project is built
   - **Docker Compose** task to start your containers

For advanced path mapping (if breakpoints don't work):

1. In the run configuration, go to the **JavaScript Debug** section
2. Add path mappings:
   - **Local path**: `$PROJECT_DIR$/apps/my-nest-app/src`
   - **Remote path**: `/app/my-nest-app`
3. Ensure **Use JavaScript debugger for Node.js** is enabled

{% /tab %}
{% /tabs %}

## Step 4: Enable Source Maps

Ensure your NestJS application is built with source maps enabled. The configuration depends on how your build target is set up:

{% tabs %}
{% tab label="@nx/webpack executor" %}

```json {% fileName="project.json" highlightLines=[12] %}
{
  "targets": {
    "build": {
      "executor": "@nx/webpack:webpack",
      "options": {
        "target": "node",
        "compiler": "tsc",
        "outputPath": "dist/apps/my-nest-app",
        "main": "apps/my-nest-app/src/main.ts",
        "tsConfig": "apps/my-nest-app/tsconfig.app.json",
        "optimization": false,
        "sourceMap": true,
        "generatePackageJson": true
      }
    }
  }
}
```

{% /tab %}
{% tab label="webpack-cli (NestJS default)" %}

If your build target uses `nx:run-commands` with `webpack-cli build`, ensure your `webpack.config.js` includes:

```javascript {% fileName="webpack.config.js" highlightLines=[17] %}
const { NxAppWebpackPlugin } = require('@nx/webpack');

module.exports = {
  output: {
    path: path.join(__dirname, '../dist/my-nest-app'),
  },
  plugins: [
    new NxAppWebpackPlugin({
      target: 'node',
      compiler: 'tsc',
      main: './src/main.ts',
      tsConfig: './tsconfig.app.json',
      assets: ['./src/assets'],
      optimization: false,
      outputHashing: 'none',
      generatePackageJson: true,
      sourceMap: true, // Enable source maps
    }),
  ],
};
```

{% /tab %}
{% /tabs %}

## Step 5: Debugging Workflow

### Build and Start the Container

1. Build your application:

   ```shell
   nx build my-nest-app
   ```

2. Start the Docker Compose services:

   ```shell
   docker-compose up --build
   ```

3. Wait for the application to start. You should see logs indicating the debugger is listening:
   ```
   Debugger listening on ws://0.0.0.0:9229/...
   ```

### Attach IDE Debugger

{% tabs %}
{% tab label="VSCode" %}

1. Set breakpoints in your TypeScript source files
2. Open VSCode's Run and Debug panel (Ctrl+Shift+D)
3. Select "Docker: Debug NestJS with Build" from the configuration dropdown
4. Click the green play button or press F5

VSCode will connect to the running container and you can debug as normal.

{% /tab %}
{% tab label="IntelliJ IDEA" %}

1. Set breakpoints in your TypeScript source files
2. Go to **Run** → **Debug...** or click the debug icon in the toolbar
3. Select your "Docker: Debug NestJS" configuration
4. Click the debug button

IntelliJ IDEA will connect to the running container and you can debug as normal. The debugger will automatically pause at breakpoints and allow you to inspect variables, step through code, and evaluate expressions.

{% /tab %}
{% /tabs %}

### Verify the Setup

To verify everything is working correctly:

1. **Check the container logs** for the debugger message:

   ```
   Debugger listening on ws://0.0.0.0:9229/[uuid]
   For help, see: https://nodejs.org/en/docs/inspector
   ```

2. **Test the debug connection** by setting a breakpoint in your `main.ts` file
3. **Make a request** to your application to trigger the breakpoint
4. **Confirm your IDE** pauses at the breakpoint and shows variable values

## Troubleshooting

### Common Issues

**Breakpoints not hitting:**

- Ensure source maps are enabled in your build configuration
- Verify the `localRoot` and `remoteRoot` paths in your launch configuration
- Check that the TypeScript files are correctly mapped to the compiled JavaScript

**Cannot connect to debugger:**

- Verify the debug port (9229) is exposed in both Dockerfile and docker-compose.yml
- Ensure the container is running and the debugger is listening
- Check that no firewall is blocking the debug port

**Source maps not working:**

- Ensure `sourceMap: true` in your build configuration
- Verify the `outFiles` path in launch.json matches your build output
- Check that the source files are available at the `localRoot` path
- For NestJS apps, the main executable might be in a subdirectory within the container

**Path mapping issues:**

- If using a project structure like `apps/my-nest-app/`, ensure the `localRoot` points to your source directory: `${workspaceFolder}/apps/my-nest-app/src`
- The `remoteRoot` should match the working directory in the container: `/app/my-nest-app` (where `my-nest-app` is the sanitized project name)
- The `outFiles` should point to the compiled JavaScript: `${workspaceFolder}/dist/apps/my-nest-app/**/*.js`

**Port conflicts:**

- The default debug port is 9229, but you can use any available port if running multiple debuggers
- Update the port in three places: Dockerfile `EXPOSE` and `CMD`, docker-compose.yml port mapping, and your IDE's debug configuration `port` property
- Common alternative debug ports: 9230, 9231, 9232, etc.

### Advanced Configuration

For complex setups with multiple services or custom build processes:

1. **Multiple NestJS services**: Create separate launch configurations for each service with different debug ports
2. **Custom build outputs**: Adjust the `remoteRoot` and `outFiles` paths accordingly
3. **Hot reloading**: Mount your source code as volumes and use `nodemon` with `--inspect` for development

## Docker Compose with Hot Reloading

For development with hot reloading, you can modify your setup:

```yaml
# docker-compose.dev.yml
version: '3.8'
services:
  my-nest-app:
    build:
      context: .
      dockerfile: apps/my-nest-app/Dockerfile.dev
    ports:
      - '3000:3000'
      - '9229:9229'
    volumes:
      - ./apps/my-nest-app/src:/app/src
      - ./dist/apps/my-nest-app:/app/dist
    command: ['npx', 'nodemon', '--inspect=0.0.0.0:9229', 'dist/main.js']
    environment:
      - NODE_ENV=development
```

This setup allows you to rebuild and restart the application automatically when source files change, while maintaining the debug connection.

## See Also

- [Node.js debugging getting started guide](https://nodejs.org/en/docs/guides/debugging-getting-started/#inspector-clients)
- [VSCode Node.js debugging](https://code.visualstudio.com/docs/nodejs/nodejs-debugging)
- [IntelliJ IDEA Node.js debugging](https://www.jetbrains.com/help/idea/running-and-debugging-node-js.html)
- [@nx/node plugin documentation](/technologies/node/introduction)
- [@nx/nest plugin documentation](/technologies/node/nest/introduction)
