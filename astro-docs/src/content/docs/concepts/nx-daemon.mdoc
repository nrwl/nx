---
title: Nx Daemon
description: Learn about the Nx Daemon, a background process that speeds up project graph computation in large workspaces by maintaining state between commands.
sidebar:
  order: 1
filter: 'type:Concepts'
---

In version 13 we introduced the opt-in Nx Daemon which Nx can leverage to dramatically speed up project graph computation, particularly for large workspaces.

## Why is it needed?

Every time you invoke a target directly, such as `nx test myapp`, or run affected commands, such `nx affected:test`, Nx first needs to generate a project graph in order to figure out how all the different projects and files within your workspace fit together. Naturally, the larger your workspace gets, the more expensive this project graph generation becomes.

Thankfully, because Nx stores its metadata on disk, Nx only recomputes what has changed since the last command invocation.

This helps quite a bit, but the recomputation is not very surgical because there is no way for Nx to know what kind of changes you have made, so it has to consider a wide range of possibilities when recomputing the project graph, even with the cache available.

## What is Nx Daemon

The Nx Daemon is a process which runs in the background on your local machine. There is one unique Nx Daemon per Nx workspace meaning if you have multiple Nx workspaces on your machine active at the same time, the corresponding Nx Daemon instances will operate independently of one another and can be on different versions of Nx.

{% aside type="note" title="Mac & Linux" %}
On macOS and linux, the server runs as a unix socket, and on Windows it runs as a named pipe.
{% /aside %}

The Nx Daemon is more efficient at recomputing the project graph because it watches the files in your workspaces and updates the project graph right away (intelligently throttling to ensure minimal recomputation). It also keeps everything in memory, so the response tends to be a lot faster.

In order to be most efficient, the Nx Daemon has some built in mechanisms to automatically shut down (including removing all file watchers) when it is not needed. These include:

- after 3 hours of inactivity (meaning the workspace's Nx Daemon did not receive any requests or detect any file changes in that time)
- when the Nx installation changes

If you ever need to manually shut down the Nx Daemon, you can run `nx reset` within the workspace in question.

## Turning it Off

The Nx Daemon is enabled by default when running on your local machine. If you want to turn it off

- set `useDaemonProcess: false` in the runners options in `nx.json` or
- set the `NX_DAEMON` env variable to `false`.

When using Nx in a CI environment, the Nx Daemon is disabled by default. Whether the process runs is determined by the following function: [https://github.com/nrwl/nx/blob/master/packages/nx/src/utils/is-ci.ts](https://github.com/nrwl/nx/blob/master/packages/nx/src/utils/is-ci.ts)

## Logs

To see information about the running Nx Daemon (such as its background process ID and log output file), run `nx daemon`. Once you have the path to that log file, you could either open it in your IDE or stream updates in a separate terminal window by running `tail -f {REPLACE_WITH_LOG_PATH}`, for example.

## Customizing the socket location

The Nx Daemon uses a unix socket to communicate between the daemon and the Nx processes. By default this socket gets placed in a temp directory. If you are using Nx in a docker-compose environment, however, you may want to run the daemon manually
and control its location to enable sharing the daemon among your docker containers. To do so, simply set the NX_DAEMON_SOCKET_DIR environment variable to a shared directory.

## Running Nx in Docker

Docker containers present unique challenges for the Nx Daemon due to their ephemeral nature and filesystem behavior.

### Why the daemon often fails in Docker

The daemon relies on stable host conditions that containers typically do not provide:

- Containers have **ephemeral filesystems** that reset on restart
- Volume mounts create **inode/mtime changes** that confuse file watching
- Containers **restart frequently** during development
- No stable **inter-process communication channel** between container restarts
- Node processes inside Docker may have **different permissions**

As a result, the daemon may fail to start, restart repeatedly, or provide inconsistent results.

### Recommended: Disable the daemon in Docker

For most container-based workflows, the simplest and most reliable approach is to disable the daemon:

```shell
NX_DAEMON=false nx build myapp
```

You can set this in your Dockerfile:

```dockerfile
ENV NX_DAEMON=false
```

Or in docker-compose:

```yaml
services:
  dev:
    environment:
      - NX_DAEMON=false
```

This switches Nx into a fully deterministic, stateless mode.

### Example: docker-compose setup for local development

```yaml
services:
  dev:
    image: node:20
    working_dir: /workspace
    volumes:
      - .:/workspace
      - /workspace/node_modules
    environment:
      - NX_DAEMON=false
    command: sh -c "npm install && nx serve myapp"
```

This approach ensures consistent builds even when containers restart or mounts change.

### CI/CD: Prefer stateless builds

Most CI environments (GitHub Actions, GitLab CI, etc.) use fresh containers on every run. In these workflows:

- The daemon offers little benefit since containers are ephemeral
- Stateless, content-based builds are more reliable
- Use [Nx Cloud remote caching](/ci/features/remote-cache) for faster builds instead of relying on daemon caching

{% aside type="note" title="Rule of thumb" %}
Use the daemon on stable hosts (local machines without containers). Disable it (`NX_DAEMON=false`) in ephemeral or container-based environments.
{% /aside %}
