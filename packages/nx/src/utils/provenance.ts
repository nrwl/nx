import { execFile } from 'child_process';
import { join } from 'path';
import { promisify } from 'util';
import { readJsonFile } from './fileutils';

/*
 * Verifies that the given npm package has provenance attestations
 * generated by the GitHub Actions workflow at .github/workflows/publish.yml
 * in the nrwl/nx repository.
 *
 * Will throw if the package does not have valid provenance.
 */
export async function ensurePackageHasProvenance(
  packageName: string,
  packageVersion: string
): Promise<void> {
  // this is used for locally released versions without provenance
  // do not set this for other reasons or you might be exposed to security risks
  if (process.env.NX_SKIP_PROVENANCE_CHECK) {
    return;
  }

  const execFileAsync = promisify(execFile);

  let npmViewResult: any;
  try {
    const result = await execFileAsync(
      'npm',
      ['view', `${packageName}@${packageVersion}`, '--json', '--silent'],
      {
        timeout: 20000,
      }
    );

    if (!result || !result.stdout) {
      throw new Error('npm view command returned empty output');
    }

    npmViewResult = JSON.parse(result.stdout.trim());
  } catch (error) {
    throw noProvenanceError(
      packageName,
      packageVersion,
      error.message || error
    );
  }

  const attURL = npmViewResult.dist?.attestations?.url;

  if (!attURL)
    throw noProvenanceError(
      packageName,
      packageVersion,
      'No attestation URL found'
    );

  let attestations: { attestations: Attestation[] };
  try {
    const response = await fetch(attURL);

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    const jsonResponse = await response.json();

    if (!jsonResponse || typeof jsonResponse !== 'object') {
      throw new Error('Invalid attestation response format');
    }
    
    attestations = jsonResponse as { attestations: Attestation[] };
  } catch (error) {
    throw noProvenanceError(
      packageName,
      packageVersion,
      error.message || error
    );
  }

  const provenanceAttestation = attestations?.attestations?.find(
    (a) => a.predicateType === 'https://slsa.dev/provenance/v1'
  );
  if (!provenanceAttestation)
    throw noProvenanceError(
      packageName,
      packageVersion,
      'No provenance attestation found'
    );

  let dsseEnvelopePayload: any;
  try {
    if (!provenanceAttestation.bundle?.dsseEnvelope?.payload) {
      throw new Error('Missing DSSE envelope payload in attestation');
    }

    const decodedBuffer = Buffer.from(
      provenanceAttestation.bundle.dsseEnvelope.payload,
      'base64'
    );

    const decodedString = decodedBuffer.toString();

    dsseEnvelopePayload = JSON.parse(decodedString);

    if (!dsseEnvelopePayload || typeof dsseEnvelopePayload !== 'object') {
      throw new Error('Invalid payload structure');
    }
  } catch (error) {
    throw noProvenanceError(
      packageName,
      packageVersion,
      error.message || error
    );
  }

  const workflowParameters =
    dsseEnvelopePayload?.predicate?.buildDefinition?.externalParameters
      ?.workflow;

  // verify that provenance was actually generated from the right publishing workflow
  if (!workflowParameters) {
    throw noProvenanceError(
      packageName,
      packageVersion,
      'Missing workflow parameters in attestation'
    );
  }

  if (workflowParameters.repository !== 'https://github.com/nrwl/nx') {
    throw noProvenanceError(
      packageName,
      packageVersion,
      'Repository does not match nrwl/nx'
    );
  }
  if (workflowParameters.path !== '.github/workflows/publish.yml') {
    throw noProvenanceError(
      packageName,
      packageVersion,
      'Publishing workflow does not match .github/workflows/publish.yml'
    );
  }
  if (workflowParameters.ref !== `refs/tags/${npmViewResult.version}`) {
    throw noProvenanceError(
      packageName,
      packageVersion,
      `Version ref does not match refs/tags/${npmViewResult.version}`
    );
  }

  // verify that provenance was generated from the exact same artifact as the one we are installing
  if (!npmViewResult.dist?.integrity) {
    throw noProvenanceError(
      packageName,
      packageVersion,
      'Missing integrity hash in package metadata'
    );
  }

  if (!dsseEnvelopePayload.subject?.[0]?.digest?.sha512) {
    throw noProvenanceError(
      packageName,
      packageVersion,
      'Missing SHA512 digest in attestation'
    );
  }

  const distSha = Buffer.from(
    npmViewResult.dist.integrity.replace('sha512-', ''),
    'base64'
  ).toString('hex');
  const attestationSha = dsseEnvelopePayload.subject[0].digest.sha512;
  if (distSha !== attestationSha) {
    throw noProvenanceError(
      packageName,
      packageVersion,
      'Integrity hash does not match attestation hash'
    );
  }
  return;
}

export const noProvenanceError = (
  packageName: string,
  packageVersion: string,
  error?: string
) =>
  `An error occurred while checking the provenance of ${packageName}@${packageVersion}. This could indicate a security risk. Please double check https://www.npmjs.com/package/${packageName} to see if the package is published correctly or file an issue at https://github.com/nrwl/nx/issues \n Error: ${
    error ?? ''
  }`;

export function getNxPackageGroup(): string[] {
  const packageJsonPath = join(__dirname, '../../package.json');
  const packageJson = readJsonFile(packageJsonPath);

  if (!packageJson['nx-migrations']?.packageGroup) {
    return ['nx'];
  }

  const packages = packageJson['nx-migrations'].packageGroup.filter(
    (dep: any) => typeof dep === 'string' && dep.startsWith('@nx/')
  );
  packages.push('nx');
  return packages;
}

type Attestation = {
  predicateType: string;
  bundle: {
    dsseEnvelope: {
      payload: string; // base64 encoded JSON
      payloadType: string;
      signatures: {
        keyid: string;
        sig: string;
      }[];
    };
    mediaType: string;
    [x: string]: unknown;
  };
  [x: string]: unknown;
};

// referh to https://slsa.dev/spec/v1.1/provenance#schema
export type DecodedAttestationPayload = {
  _type: 'https://in-toto.io/Statement/v1';
  subject: unknown[];
  predicateType: 'https://slsa.dev/provenance/v1';
  predicate: {
    buildDefinition: {
      buildType: string;
      externalParameters: Record<string, any>;
      internalParameters?: Record<string, any>;
      resolvedDependencies?: ResourceDescriptor[];
    };
    runDetails: {
      builder: {
        id: string;
        builderDependencies?: ResourceDescriptor[];
        version?: Record<string, string>;
      };
      metadata?: {
        invocationId?: string;
        startedOn?: string; // <YYYY>-<MM>-<DD>T<hh>:<mm>:<ss>Z
        finishedOn?: string; // <YYYY>-<MM>-<DD>T<hh>:<mm>:<ss>Z
      };
      byproducts?: ResourceDescriptor[];
    };
  };
};

export interface ResourceDescriptor {
  uri?: string;
  digest?: {
    sha256?: string;
    sha512?: string;
    gitCommit?: string;
    [key: string]: string | undefined;
  };
  name?: string;
  downloadLocation?: string;
  mediaType?: string;
  content?: string;
  annotations?: {
    [key: string]: any;
  };
}
