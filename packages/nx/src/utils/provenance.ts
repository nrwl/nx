import { execSync } from 'child_process';
import { join } from 'path';
import { promisify } from 'util';
import { readJsonFile } from './fileutils';
import {
  detectPackageManager,
  getPackageManagerCommand,
  packageRegistryView,
} from './package-manager';

/*
 * Verifies that the given npm package has provenance attestations
 * generated by the GitHub Actions workflow at .github/workflows/publish.yml
 * in the nrwl/nx repository.
 *
 * Will throw if the package does not have valid provenance.
 */
export async function ensurePackageHasProvenance(
  packageName: string,
  packageVersion: string
): Promise<void> {
  // this is used for locally released versions without provenance
  // do not set this for other reasons or you might be exposed to security risks
  if (process.env.NX_SKIP_PROVENANCE_CHECK) {
    return;
  }

  try {
    const result = await packageRegistryView(
      packageName,
      packageVersion,
      '--json --silent'
    );
    const npmViewResult = JSON.parse(result);

    const attURL = npmViewResult.dist?.attestations?.url;

    if (!attURL)
      throw new ProvenanceError(
        packageName,
        packageVersion,
        'No attestation URL found'
      );

    const response = await fetch(attURL);

    if (!response.ok) {
      throw new ProvenanceError(
        packageName,
        packageVersion,
        `HTTP ${response.status}: ${response.statusText}`
      );
    }

    const attestations = (await response.json()) as {
      attestations: Attestation[];
    };

    const provenanceAttestation = attestations?.attestations?.find(
      (a) => a.predicateType === 'https://slsa.dev/provenance/v1'
    );

    const dsseEnvelopePayload = JSON.parse(
      Buffer.from(
        provenanceAttestation.bundle.dsseEnvelope.payload,
        'base64'
      ).toString()
    );

    const workflowParameters =
      dsseEnvelopePayload?.predicate?.buildDefinition?.externalParameters
        ?.workflow;

    // verify that provenance was actually generated from the right publishing workflow
    if (!workflowParameters) {
      throw new ProvenanceError(
        packageName,
        packageVersion,
        'Missing workflow parameters in attestation'
      );
    }

    if (workflowParameters.repository !== 'https://github.com/nrwl/nx') {
      throw new ProvenanceError(
        packageName,
        packageVersion,
        'Repository does not match nrwl/nx'
      );
    }
    if (workflowParameters.path !== '.github/workflows/publish.yml') {
      throw new ProvenanceError(
        packageName,
        packageVersion,
        'Publishing workflow does not match .github/workflows/publish.yml'
      );
    }
    if (workflowParameters.ref !== `refs/tags/${npmViewResult.version}`) {
      throw new ProvenanceError(
        packageName,
        packageVersion,
        `Version ref does not match refs/tags/${npmViewResult.version}`
      );
    }

    // verify that provenance was generated from the exact same artifact as the one we are installing
    const distSha = Buffer.from(
      npmViewResult.dist.integrity.replace('sha512-', ''),
      'base64'
    ).toString('hex');
    const attestationSha = dsseEnvelopePayload.subject[0].digest.sha512;
    if (distSha !== attestationSha) {
      throw new ProvenanceError(
        packageName,
        packageVersion,
        'Integrity hash does not match attestation hash'
      );
    }
    return;
  } catch (error) {
    if (error instanceof ProvenanceError) {
      throw error;
    }
    throw new ProvenanceError(
      packageName,
      packageVersion,
      error.message || error
    );
  }
}

export class ProvenanceError extends Error {
  constructor(packageName: string, packageVersion: string, error?: string) {
    let customRegistry: string | undefined = undefined;
    try {
      const packageManager = detectPackageManager();
      const commands = getPackageManagerCommand(packageManager);

      // Try to get registry from current package manager, fall back to npm
      const registryCommand =
        commands.getRegistryUrl ?? 'npm config get registry';

      const registry = execSync(registryCommand, {
        timeout: 5000,
        windowsHide: true,
        encoding: 'utf-8',
      }).trim();

      // Only consider it custom if it's not the default npm registry
      if (
        registry &&
        registry !== 'undefined' &&
        !registry.includes('registry.npmjs.org')
      ) {
        customRegistry = registry;
      }
    } catch {
      // If we can't determine the registry, proceed with default error message
    }
    const registryNote = customRegistry
      ? `This might be due to a custom registry configuration (${customRegistry}). Please check whether provenance is correctly configured for your registry.`
      : `This could indicate a security risk. Please double check https://www.npmjs.com/package/${packageName} to see if the package is published correctly or file an issue at https://github.com/nrwl/nx/issues.`;
    super(
      `An error occurred while checking the provenance of ${packageName}@${packageVersion}. ${registryNote} To disable this check at your own risk, you can set the NX_SKIP_PROVENANCE_CHECK environment variable to true. \n Error: ${
        error ?? ''
      }`
    );
  }
}

export function getNxPackageGroup(): string[] {
  const packageJsonPath = join(__dirname, '../../package.json');
  const packageJson = readJsonFile(packageJsonPath);

  if (!packageJson['nx-migrations']?.packageGroup) {
    return ['nx'];
  }

  const packages = packageJson['nx-migrations'].packageGroup.filter(
    (dep: any) => typeof dep === 'string' && dep.startsWith('@nx/')
  );
  packages.push('nx');
  return packages;
}

type Attestation = {
  predicateType: string;
  bundle: {
    dsseEnvelope: {
      payload: string; // base64 encoded JSON
      payloadType: string;
      signatures: {
        keyid: string;
        sig: string;
      }[];
    };
    mediaType: string;
    [x: string]: unknown;
  };
  [x: string]: unknown;
};

// referh to https://slsa.dev/spec/v1.1/provenance#schema
export type DecodedAttestationPayload = {
  _type: 'https://in-toto.io/Statement/v1';
  subject: unknown[];
  predicateType: 'https://slsa.dev/provenance/v1';
  predicate: {
    buildDefinition: {
      buildType: string;
      externalParameters: Record<string, any>;
      internalParameters?: Record<string, any>;
      resolvedDependencies?: ResourceDescriptor[];
    };
    runDetails: {
      builder: {
        id: string;
        builderDependencies?: ResourceDescriptor[];
        version?: Record<string, string>;
      };
      metadata?: {
        invocationId?: string;
        startedOn?: string; // <YYYY>-<MM>-<DD>T<hh>:<mm>:<ss>Z
        finishedOn?: string; // <YYYY>-<MM>-<DD>T<hh>:<mm>:<ss>Z
      };
      byproducts?: ResourceDescriptor[];
    };
  };
};

export interface ResourceDescriptor {
  uri?: string;
  digest?: {
    sha256?: string;
    sha512?: string;
    gitCommit?: string;
    [key: string]: string | undefined;
  };
  name?: string;
  downloadLocation?: string;
  mediaType?: string;
  content?: string;
  annotations?: {
    [key: string]: any;
  };
}
