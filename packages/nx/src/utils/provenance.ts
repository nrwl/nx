import { execFile } from 'child_process';
import { join } from 'path';
import { promisify } from 'util';
import { readJsonFile } from './fileutils';
import { platform } from 'os';

/*
 * Verifies that the given npm package has provenance attestations
 * generated by the GitHub Actions workflow at .github/workflows/publish.yml
 * in the nrwl/nx repository.
 *
 * Will throw if the package does not have valid provenance.
 */
export async function ensurePackageHasProvenance(
  packageName: string,
  packageVersion: string
): Promise<void> {
  // this is used for locally released versions without provenance
  // do not set this for other reasons or you might be exposed to security risks
  // also skip this check during e2e tests because those rely on local packages without provenance
  if (process.env.NX_SKIP_PROVENANCE_CHECK) {
    return;
  }

  const execFileAsync = promisify(execFile);
  try {
    const result = await execFileAsync(
      platform() === 'win32' ? 'npm.cmd' : 'npm',
      ['view', `${packageName}@${packageVersion}`, '--json', '--silent'],
      {
        timeout: 20000,
      }
    );
    const npmViewResult = JSON.parse(result.stdout.trim());

    const attURL = npmViewResult.dist?.attestations?.url;

    if (!attURL)
      throw new ProvenanceError(
        packageName,
        packageVersion,
        'No attestation URL found'
      );

    const response = await fetch(attURL);

    if (!response.ok) {
      throw new ProvenanceError(
        packageName,
        packageVersion,
        `HTTP ${response.status}: ${response.statusText}`
      );
    }

    const attestations = (await response.json()) as {
      attestations: Attestation[];
    };

    const provenanceAttestation = attestations?.attestations?.find(
      (a) => a.predicateType === 'https://slsa.dev/provenance/v1'
    );

    const dsseEnvelopePayload = JSON.parse(
      Buffer.from(
        provenanceAttestation.bundle.dsseEnvelope.payload,
        'base64'
      ).toString()
    );

    const workflowParameters =
      dsseEnvelopePayload?.predicate?.buildDefinition?.externalParameters
        ?.workflow;

    // verify that provenance was actually generated from the right publishing workflow
    if (!workflowParameters) {
      throw new ProvenanceError(
        packageName,
        packageVersion,
        'Missing workflow parameters in attestation'
      );
    }

    if (workflowParameters.repository !== 'https://github.com/nrwl/nx') {
      throw new ProvenanceError(
        packageName,
        packageVersion,
        'Repository does not match nrwl/nx'
      );
    }
    if (workflowParameters.path !== '.github/workflows/publish.yml') {
      throw new ProvenanceError(
        packageName,
        packageVersion,
        'Publishing workflow does not match .github/workflows/publish.yml'
      );
    }
    if (workflowParameters.ref !== `refs/tags/${npmViewResult.version}`) {
      throw new ProvenanceError(
        packageName,
        packageVersion,
        `Version ref does not match refs/tags/${npmViewResult.version}`
      );
    }

    // verify that provenance was generated from the exact same artifact as the one we are installing
    const distSha = Buffer.from(
      npmViewResult.dist.integrity.replace('sha512-', ''),
      'base64'
    ).toString('hex');
    const attestationSha = dsseEnvelopePayload.subject[0].digest.sha512;
    if (distSha !== attestationSha) {
      throw new ProvenanceError(
        packageName,
        packageVersion,
        'Integrity hash does not match attestation hash'
      );
    }
    return;
  } catch (error) {
    if (error instanceof ProvenanceError) {
      throw error;
    }
    throw new ProvenanceError(
      packageName,
      packageVersion,
      error.message || error
    );
  }
}

export class ProvenanceError extends Error {
  constructor(packageName: string, packageVersion: string, error?: string) {
    super(
      `An error occurred while checking the provenance of ${packageName}@${packageVersion}. This could indicate a security risk. Please double check https://www.npmjs.com/package/${packageName} to see if the package is published correctly or file an issue at https://github.com/nrwl/nx/issues. To disable this check at your own risk, you can set the NX_SKIP_PROVENANCE_CHECK environment variable to true. \n Error: ${
        error ?? ''
      }`
    );
  }
}

export function getNxPackageGroup(): string[] {
  const packageJsonPath = join(__dirname, '../../package.json');
  const packageJson = readJsonFile(packageJsonPath);

  if (!packageJson['nx-migrations']?.packageGroup) {
    return ['nx'];
  }

  const packages = packageJson['nx-migrations'].packageGroup.filter(
    (dep: any) => typeof dep === 'string' && dep.startsWith('@nx/')
  );
  packages.push('nx');
  return packages;
}

type Attestation = {
  predicateType: string;
  bundle: {
    dsseEnvelope: {
      payload: string; // base64 encoded JSON
      payloadType: string;
      signatures: {
        keyid: string;
        sig: string;
      }[];
    };
    mediaType: string;
    [x: string]: unknown;
  };
  [x: string]: unknown;
};

// referh to https://slsa.dev/spec/v1.1/provenance#schema
export type DecodedAttestationPayload = {
  _type: 'https://in-toto.io/Statement/v1';
  subject: unknown[];
  predicateType: 'https://slsa.dev/provenance/v1';
  predicate: {
    buildDefinition: {
      buildType: string;
      externalParameters: Record<string, any>;
      internalParameters?: Record<string, any>;
      resolvedDependencies?: ResourceDescriptor[];
    };
    runDetails: {
      builder: {
        id: string;
        builderDependencies?: ResourceDescriptor[];
        version?: Record<string, string>;
      };
      metadata?: {
        invocationId?: string;
        startedOn?: string; // <YYYY>-<MM>-<DD>T<hh>:<mm>:<ss>Z
        finishedOn?: string; // <YYYY>-<MM>-<DD>T<hh>:<mm>:<ss>Z
      };
      byproducts?: ResourceDescriptor[];
    };
  };
};

export interface ResourceDescriptor {
  uri?: string;
  digest?: {
    sha256?: string;
    sha512?: string;
    gitCommit?: string;
    [key: string]: string | undefined;
  };
  name?: string;
  downloadLocation?: string;
  mediaType?: string;
  content?: string;
  annotations?: {
    [key: string]: any;
  };
}
