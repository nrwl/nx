package dev.nx.maven

import de.skuzzle.test.snapshots.EnableSnapshotTests
import de.skuzzle.test.snapshots.Snapshot
import org.apache.maven.execution.MavenSession
import org.apache.maven.model.Model
import org.apache.maven.model.io.xpp3.MavenXpp3Reader
import org.apache.maven.plugin.MavenPluginManager
import org.apache.maven.project.MavenProject
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.mockito.Mockito.mock
import java.io.File
import java.io.FileReader

/**
 * Snapshot tests for PhaseAnalyzer using simplified Maven setup
 */
@EnableSnapshotTests
class PhaseAnalyzerSnapshotTest {

    private lateinit var analyzer: PhaseAnalyzer
    private lateinit var testProject: MavenProject

    @BeforeEach
    fun setUp() {
        // Create mock session and plugin manager for basic functionality
        val session = mock(MavenSession::class.java)
        val pluginManager = mock(MavenPluginManager::class.java)

        // Load the test project
        testProject = loadTestProject()

        // Create PhaseAnalyzer with mock components for basic testing
        val expressionResolver = MavenExpressionResolver(session)
        val pathResolver = PathResolver(testProject.basedir.absolutePath, testProject.basedir.absolutePath, session)

        analyzer = PhaseAnalyzer(pluginManager, session, expressionResolver, pathResolver)
    }

    private fun loadTestProject(): MavenProject {
        val testPom = File("src/test/resources/phase-analyzer-tests/full-lifecycle-project/pom.xml")
        val reader = MavenXpp3Reader()
        val model: Model = FileReader(testPom).use { reader.read(it) }

        val project = MavenProject(model)
        project.file = testPom
        project.basedir = testPom.parentFile

        return project
    }

    @Test
    fun testAllMavenLifecyclePhases(snapshot: Snapshot) {
        // Standard Maven lifecycle phases
        val phases = listOf(
            "validate",
            "initialize",
            "generate-sources",
            "process-sources",
            "generate-resources",
            "process-resources",
            "compile",
            "process-classes",
            "generate-test-sources",
            "process-test-sources",
            "generate-test-resources",
            "process-test-resources",
            "test-compile",
            "process-test-classes",
            "test",
            "prepare-package",
            "package",
            "pre-integration-test",
            "integration-test",
            "post-integration-test",
            "verify",
            "install",
            "deploy"
        )

        // Analyze all phases
        val phaseResults = phases.associateWith { phase ->
            try {
                val result = analyzer.analyze(testProject, phase)
                PhaseAnalysisResult(
                    isThreadSafe = result.isThreadSafe,
                    isCacheable = result.isCacheable,
                    inputs = result.inputs.sorted(),
                    outputs = result.outputs.sorted(),
                    error = null
                )
            } catch (e: Exception) {
                PhaseAnalysisResult(
                    isThreadSafe = true,
                    isCacheable = true,
                    inputs = emptyList(),
                    outputs = emptyList(),
                    error = e.message
                )
            }
        }

        // Create snapshot
        snapshot.assertThat(phaseResults).`as`("all-maven-lifecycle-phases").matchesSnapshot()
    }

    @Test
    fun testSpecificPhaseDetails(snapshot: Snapshot) {
        // Test specific phases that should have predictable behavior
        val specificPhases = mapOf(
            "compile" to "Standard compile phase with compiler plugin",
            "test" to "Test phase with surefire plugin",
            "package" to "Package phase with jar plugin",
            "deploy" to "Deploy phase - should be non-cacheable",
            "install" to "Install phase - should be non-cacheable"
        )

        val detailedResults = specificPhases.mapValues { (phase, description) ->
            val result = analyzer.analyze(testProject, phase)
            PhaseDetailedResult(
                description = description,
                isThreadSafe = result.isThreadSafe,
                isCacheable = result.isCacheable,
                inputs = result.inputs.sorted(),
                outputs = result.outputs.sorted(),
                inputCount = result.inputs.size,
                outputCount = result.outputs.size
            )
        }

        snapshot.assertThat(detailedResults).`as`("specific-phase-details").matchesSnapshot()
    }

    @Test
    fun testEmptyAndUnknownPhases(snapshot: Snapshot) {
        // Test phases that might not have any plugins
        val edgeCasePhases = listOf(
            "non-existent-phase",
            "custom-phase",
            ""
        )

        val edgeCaseResults = edgeCasePhases.associateWith { phase ->
            try {
                val result = analyzer.analyze(testProject, phase)
                PhaseAnalysisResult(
                    isThreadSafe = result.isThreadSafe,
                    isCacheable = result.isCacheable,
                    inputs = result.inputs.sorted(),
                    outputs = result.outputs.sorted(),
                    error = null
                )
            } catch (e: Exception) {
                PhaseAnalysisResult(
                    isThreadSafe = true,
                    isCacheable = true,
                    inputs = emptyList(),
                    outputs = emptyList(),
                    error = e.message
                )
            }
        }

        snapshot.assertThat(edgeCaseResults).`as`("empty-and-unknown-phases").matchesSnapshot()
    }
}

/**
 * Data class for snapshot serialization
 */
data class PhaseAnalysisResult(
    val isThreadSafe: Boolean,
    val isCacheable: Boolean,
    val inputs: List<String>,
    val outputs: List<String>,
    val error: String?
)

/**
 * Data class for detailed phase analysis
 */
data class PhaseDetailedResult(
    val description: String,
    val isThreadSafe: Boolean,
    val isCacheable: Boolean,
    val inputs: List<String>,
    val outputs: List<String>,
    val inputCount: Int,
    val outputCount: Int
)